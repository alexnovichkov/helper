#ifndef STL_ITERATORS_H
#define STL_ITERATORS_H

#include <vector>
#include <list>
#include <array>
#include <valarray>
#include <iostream>
#include <iterator>

//Стандартная библиотека C++ (STL) построена на трех "столпах" - контейнеры, итераторы и алгоритмы.
//Контейнер - это хранилище данных. Доступ к элементам осуществляется с помощью итераторов,
//операции над элементами - с помощью методов контейнера, или с помощью обобщенных алгоритмов.

//#include <iterator>

///Виды итераторов

//Итераторы - это "клей" между контейнерами и алгоритмами. Они позволяют перебрать все элементы
//контейнера, скрывая особенности хранения данных в контейнере.
//STL определяет следующие виды итераторов:
//  Прямой - Forward (F): Итератор, проходящий элементы контейнера
//           с начала в конец
//  Двунаправленный - Bidirectional (B): Прямой итератор, который также может проходить
//                    элементы контейнера с конца в начало
//  Произвольный - Random (R): Двунаправленный итератор, который также обеспечивает
//                 доступ к элементу по произвольному индексу

//Каждый класс контейнера поддерживает свои типы итераторов, например, vector поддерживает R-итераторы,
//list - только B-итераторы, и т.д.

//Все итераторы поддерживают следующие операции:
//- Создание итератора, копирование и присвоение одного итератора другому
//- Сравнение итераторов друг с другом
//- Разыменование итератора для получения доступа к элементу контейнера, на который
//  указывает итератор
//- Инкремент итератора (++it, it++), позволяющие последовательно перебирать элементы.

//Следующие операции определены не для всех итераторов:
//                                          F    B    R
//Декремент (--it, it--)                    -    +    +
//Произвольный доступ (a[n])                -    -    +
//Передвижение на n (it+n, it-n)            -    -    +
//Расстояние между итераторами (it1-it2)    -    -    +
//Операторы упорядоченности (it1<it2)       -    -    +

//Все контейнеры STL предоставляют типы iterator и const_iterator, используемые для F-итераторов.
//Некоторые контейнеры также предоставляют reverse_iterator и const_reverse_iterator для R-итераторов.
//Кроме того, все контейнеры предоставляют методы для получения итераторов на начало
//и конец контейнера (обычно begin() и end() для изменяемых итераторов и cbegin() и cend()
//для константных итераторов).
//Некоторые контейнеры также имеют методы rbegin() и rend() (crbegin() и crend()) для
//итерирования в обратную сторону.
//Методы end(), cend() реализованы таким образом, что фактически они указывают на элемент
//ЗА ПОСЛЕДНИМ В КОНТЕЙНЕРЕ. Их можно считать "невалидными" итераторами, сравнение с которыми
//позволяет определить, достигли ли мы конца контейнера. Если итератор it указывает на
//последний элемент в контейнере, то ++it будет равен end().
//Аналогичным образом методы rend() и crend() возвращают итератор на элемент перед
//первым элементом контейнера.

void traversingContainer()
{
    //std::vector позволяет обходить вектор вперед и назад
    std::vector<int> vec {1,2,3,4,5,6};
    for (auto it = vec.begin(); it != vec.end(); ++it) //перебираем из начала в конец
        *it+=1;
    // vec = {2,3,4,5,6,7}
    for (auto it = vec.rbegin(); it != vec.rend(); ++it) //перебираем из конца в начало
        *it-=1;
    //vec = {1,2,3,4,5,6}
}

//Результат разыменования итератора - это не просто значение элемента. Оператор разыменования
//возвращает ССЫЛКУ на элемент, то есть с помощью итератора мы может менять значение
//элементов в списке:
void usingMutableIterators()
{
    std::list<std::string> l;
    for (auto it = l.begin(); it!=l.end(); ++it) {
        *it += "\n"; //добавляет перевод строки в конец каждого элемента списка l
    }
}
//Если нам не требуется изменять элементы, или если мы хотим использовать список в функции,
//в которую мы передали список l по константной ссылке, то обычные итераторы мы уже использовать
//не можем. Вместо них мы должны использовать константные итераторы list<string>::const_iterator
//Константные итераторы отличаются от изменяемых тем, что при их разыменовании мы получаем
//не обычную, а константную ссылку на элемент контейнера, то есть неизменяемый элемент.

void usingConstIterators()
{
    std::list<std::string> l;
    for (auto it = l.cbegin(); it!=l.cend(); ++it) {//cbegin и cend возвращают константные итераторы
        *it += "\n"; //ошибка! не можем менять значение элемента, получаемое по константному итератору.
        std::cout << *it; //можно: считывание значения не нарушает константность.
    }
    //Можно и так, используя перегруженные методы begin и end, возвращающие константные итераторы:
    using StrListConstIt = std::list<std::string>::const_iterator;

    for (StrListConstIt it = l.begin(); it!=l.end(); ++it) {
        *it += "\n"; //ошибка! нельзя менять значение элемента, получаемое по константному итератору.
        std::cout << *it; //можно: считывание значения не нарушает константность.
    }
}

void constIteratorsVsMutable()
{
    std::vector<int> vec {1,2,3,4,5,6};
    auto it = vec.begin(); //it - изменяемый итератор, указывающий на начало вектора
    *it = 10; // vec = {10,2,3,4,5,6}
    *(it+3) = *it; // vec = {10,2,3,10,5,6}
    it[3] = 11;    // vec = {10,2,3,11,5,6}

    auto const_it = vec.cbegin();
    *const_it = 11; //ошибка: попытка изменить неизменяемый элемент
}
//Совет 1: всегда используйте константные итераторы там, где вы не планируете менять значение элемента.
//Совет 2: вы можете использовать обычные итераторы, но сохранять их в константные объекты:
//const auto & it = l.begin(); //получили неконстантный итератор, но сохранили в константную ссылку.

//STL предоставляет ряд функций, позволяющих получить итераторы на начало и конец контейнера,
//не зная типа контейнера. Эти функции даже работают со статическими массивами:

//begin()    /  end()    Изменяемые итераторы
//cbegin()   /  cend()   Константные итераторы
//rbegin()   /  rend()   Обратные итераторы
//crbegin()  /  crend()  Константные обратные итераторы
void traversingArray()
{
    //обычный массив
    int array[] = {1,2,3,4,5,6};
    //перебираем элементы массива, как если бы это был вектор
    for (auto it = std::begin(array); it != std::end(array); ++it)
        *it += 1;
}
//Эти функции полезны прежде всего при написании обобщенных алгоритмов обработки элементов,
//когда неважно, в контейнере какого типа они хранятся:
template <class Container>
void printAll(const Container &c)
{
    for (auto it = std::cbegin(c); it != std::cend(c); ++it)
        std::cout << *it << " ";
}
//Теперь можно выводить в консоль любые контейнеры:
void usePrintAll()
{
    std::vector<int> vec {1,2,3,4,5};
    std::list<std::string> l {"a", "b", "c"};
    double a[] = {3.14, 2.718, 1.414};

    printAll(vec); std::cout << std::endl;
    printAll(l); std::cout << std::endl;
    printAll(a); std::cout << std::endl;
}

//Но, конечно, с использованием ranged-for циклов printAll можно переписать в более понятной форме:
template <class Container>
void betterPrintAll(const Container &c)
{
    for (const auto &element: c)
        std::cout << element << " ";
}

//Еще ряд полезных функций, не являющихся членами классов контейнеров:
//std::distance(it1, it2) : Возвращает расстояние между двумя итераторами
//     distance = 0, если it1 и it2 указывают на один элемент
//std::advance(it, dist) : Передвигает итератор на расстояние dist (может быть отрицательным).
//std::next(it, dist) : То же, что advance, но возвращает it в новой позиции
//std::prev(it, dist) : Эквивалентно advance(it, -dist)

//Задания:
//1. Напишите функцию, меняющую каждый четный элемент вектора.
//2. Напишите функцию, возвращающую первый отрицательный элемент вектора
//3. Напишите функцию, возвращающую последний отрицательный элемент вектора
//4. Напишите обобщенные варианты функций из 2 и 3, работающие с любыми контейнерами


#endif // STL_ITERATORS_H
