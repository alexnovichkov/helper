#ifndef STL_CONTAINERS_H
#define STL_CONTAINERS_H

#include <vector>
#include <list>
#include <array>
#include <forward_list>
#include <valarray>
#include <iostream>
#include <iterator>

//Стандартная библиотека C++ (STL) построена на трех "столпах" - контейнеры, итераторы и алгоритмы.
//Контейнер - это хранилище данных. Доступ к элементам осуществляется с помощью итераторов,
//операции над элементами - с помощью методов контейнера, или с помощью обобщенных алгоритмов.

///-----------------------------------------------------------------------------
///Последовательные контейнеры                                                 |
///-----------------------------------------------------------------------------

//Последовательные контейнеры позволяют хранить элементы в виде "массива" или "списка",
//они являются логическим развитием идеи обычных массивов - статических или динамических.

//STL содержит следующие классы последовательных контейнеров:
//vector - вектор, хранит элементы в непрерывном куске памяти, позволяет обходить элементы в обоих
//         направлениях, обеспечивает произвольный доступ к элементам.
//list - список, хранит элементы произвольно, за счет чего обеспечивает быструю вставку и удаление элементов.
//       Позволяет обходить элементы в обоих направлениях, но не обеспечивает произвольный доступ.
//forward_list - однонаправленный список, поддерживает только обход из начала в конец.
//deque - очередь, поддерживает быструю вставку в начало и в конец.
//array - массив, класс, призванный заменить статические массивы C. Не поддерживает изменение
//        размера.

//Кроме того, STL определяет также три т.н. адаптера контейнеров, которые реализованы поверх deque или vector:
//stack - стек, реализует структуру данных LIFO, не поддерживает итераторы и обход контейнера.
//queue - очередь, реализует структуру данных FIFO, не поддерживает итераторы и обход контейнера.
//priority_queue - очередь, в которой элемент с максимальным приоритетом всегда оказывается первым.

//Все контейнеры, кроме stack, queue и priority_queue, имеют методы, возвращающие
//итераторы на начало и конец - begin(), cbegin(), end(), cend().
//Контейнеры vector, list, deque, array также имеют методы, возвращающие
//обратные итераторы - rbegin(), crbegin(), rend(), crend().

//Доступ к произвольному элементу имеют только классы vector, deque и array, с помощью методов
//at(i) - возвращает ссылку на элемент в позиции i, проверяет i на валидность
//c[i] - возвращает ссылку на элемент в позиции i, без проверки i на валидность.

//Контейнер std::vector
//---------------------

//Это наиболее широко используемый контейнер. Он хранит элементы в непрерывном куске памяти,
//поэтому при создании больших векторов программа может упасть при попытке выделить
//необходимую память. Это необходимо помнить.

//Vector может хранить элементы любого типа - простые типы, объекты структур и классов,
//указатели на любые типы, ссылки на объекты. Размер вектора меняется автоматически при
//добавлении или удалении элементов.

class A
{
public:
    explicit A(int x): x(x) {}
    int x = 0;
};

void useVector()
{
    //объявление пустого вектора
    std::vector<double> v1;
    //объявление вектора с начальными элементами
    std::vector<double> v2 = {1.0, 2.0, 3.0};
    //объявление вектора заданной длины. Элементы имеют значения по умолчанию
    std::vector<double> v3(10);
    //объявление вектора заданной длины. Элементы имеют заданные пользователем значения
    std::vector<double> v3_(10, 3.14159);
    //объявление вектора копированием имеющегося
    std::vector<double> v4 = v2;

    //Изменение элементов вектора
    //напрямую - через индекс
    v2[1] = 2.1; //нет проверки выхода за границу
    v2.at(1) = 2.2; //есть проверка выхода за границу
    //с помощью итератора
    auto it = v2.begin(); //получаем итератор на первый элемент
    it += 2;  //передвигаем итератор на последний элемент
    *it = 3.1; //меняем элемент, на который указывает итератор
    //через методы
    v3.front() = 1;
    v3.back() = 10;
    //через прямой доступ к памяти:
    *(v3.data()+5) = 43; //метод data() возвращает указатель на динамический массив с данными вектора

    //добавление и удаление элементов
    v1.push_back(3); //вставка в конец вектора
    v1.emplace_back(4); //вставка в конец вектора без лишнего копирования
    v1.insert(v1.begin(), 1); //вставка в начало вектора
    v1.insert(v1.begin()+1, {1,2,3}); //вставка нескольких значений
    v1.insert(v1.begin(), v2.begin(), v2.end()); //вставка вектора v2 в начало вектора v1
    v1.insert(v1.begin()+2, 4, 3.5); //вставка четырех одинаковых значений
    v3.assign(10, 42.2); //заменяет все элементы в векторе десятью элементами со значением 42.2
    v3.assign({2,4,6,8}); //заменяет все элементы в векторе заданными значениями

    v1.pop_back(); //удаление последнего элемента
    auto it1 = v1.erase(v1.begin()); //удаление первого элемента. it1 - итератор на элемент, следующий за удаленным
    it1 = v1.erase(v1.begin()+2, v1.begin()+5); //удаление элементов с 3 по 6, it1 - итератор на элемент, следующий за удаленным
    v1.clear(); //удаление всех элементов вектора
    //удаление элементов в цикле
    for (auto it = v2.begin(); it != v2.end();) {
        if (*it < 1.0) it = v2.erase(it);
        else ++it;
    }

    //изменение размера вектора
    //Vector поддерживает концепции "размера" и "вместимости". Размер - это фактическое количество
    //элементов в векторе, вместимость - количество элементов, которое можно хранить
    //в векторе без необходимости перевыделять под него память.
    //При добавлении элемента, если размер вектора становится равен вместимости,
    //под вектор выделяется новый, больший кусок памяти, старое содержимое вектора копируется
    //в новое место, при этом размер увеличивается на 1, а вместимость - в зависимости от реализации
    //(может и в 2 раза). Поэтому объект класса std::vector всегда занимает в памяти
    //больше места, чем у него элементов.
    size_t size = v2.size(); //количество элементов
    size_t cap = v2.capacity(); //под какое количество элементов выделена память
    bool empty = v1.empty(); //является ли вектор пустым
    v2.resize(v2.size()*2); //увеличение длины вектора вдвое
    v1.reserve(10); //зарезервировали место под 10 элементов
    v2.shrink_to_fit(); //освободили память, не занятую элементами

    //работа с несколькими векторами
    v2 = v3; //копирование элементов вектора v3 в вектор v2;
    v1.swap(v2); //обмен содержимым между двумя векторами
    bool eq1 = v2==v3; //false, сравнение векторов
    bool eq2 = v1==v3; //true, сравнение векторов


    //Важное замечание: Если вы хотите хранить в векторе объекты класса, то этот класс должен
    //иметь публичные конструктор по умолчанию и деструктор. Например, класс A, объявленный выше,
    //нельзя поместить в вектор, так как у него нет конструктора по умолчанию:
    std::vector<A> wrongVector(10); //этот код не скомпилируется
    //Совет: всегда добавляйте в класс конструктор по умолчанию, если в нем уже есть другие конструкторы.
    //Решение проблемы: хранить в векторе не сами объекты, а указатели на них. Это решит проблему
    //с отсутствующим конструктором, но потребует дополнительной работы по созданию и
    //удалению элементов.
    std::vector<A*> v(10, nullptr);
    v[1] = new A(42);
    v[5] = new A(5);
    delete v[1];
    delete v[5];
}

//Контейнеры std::list и std::forward_list
//----------------------------------------

//Эти контейнеры представляют собой списки элементов, в которых каждый предыдущий элемент
//связан со следующим ссылкой на него, что позволяет переходить от одного элемента
//к другому от начала контейнера к концу. В контейнере std::list кроме того каждый элемент
//связан с предыдущим, что позволяет проходить список от конца к началу.
//Таким образом, std::forward_list имеет 4 метода, возвращающих итераторы на начало и конец
//и позволяющих проходить список от начала к концу: begin(), cbegin(), end(), cend()
//std::list имеет еще 4 метода, возвращающих обратные итераторы: rbegin(), crbegin(), rend(), crend()

//Элементы в контейнерах std::list и std::forward_list хранятся не в непрерывном куске памяти,
//а в произвольных местах. Поэтому вставка и удаление элементов очень быстры, если известна
//позиция элемента. Однако контейнеры не поддерживают доступ к произвольному элементу,
//то есть чтобы найти элемент в позиции n, необходимо пройти по списку до этого элемента.

//По сравнению с std::vector std::list добавляет следующие методы:
//  push_front() - для добавления элемента в начало списка
//  pop_front() - для удаления элемента из начала списка
//  merge() - сливает два отсортированных списка в один
//  splice() - переносит элементы из одного списка в другой
//  remove(), remove_if() - удаляет элементы из списка по определенному критерию
//  reverse() - переставляет элементы в обратном порядке
//  sort() - сортирует элементы
//  unique() - удаляет из списка повторяющиеся элементы

//Следующих методов нет в std::list:
//  operator[], at() - так как отсутствует доступ к произвольному элементу
//  data() - так как элементы хранятся не в одном куске памяти
//  reserve(), capacity(), shrink_to_fit() - так как нет необходимости заранее выделять память под элементы

//std::froward_list поддерживает только однонаправленные итераторы. Поэтому следующих методов в нем нет:
//  back() - так как чтобы получить последний элемент, нужно сначала пройти весь список
//  size() - так как чтобы определить размер, нужно сначала пройти весь список
//  push_back(), pop_back(), emplace_back() - по той же причине


//Контейнер std::deque
//--------------------

//Этот контейнер представляет собой двустороннюю очередь - элементы можно очень быстро
//вставлять и удалять как из начала, так и из конца. Это отличает deque от vector -
//в последнем быстрая вставка поддерживается только для конца вектора.
//std::deque хранит элементы особым образом, выделяя дополнительную память в начале и в конце контейнера.
//Поэтому обычно он требует больше памяти, чем vector. В остальном его можно использовать аналогично.

//Контейнер std::array
//--------------------

//Этот контейнер появился в С++11, так что, чтобы использовать его, необходимо в проекте
//включить соответствующую директиву.
//array предназначен заменить обычный статический массив языка C. Он используется в тех случаях,
//когда размер контейнера известен заранее и никогда не меняется. Благодаря этому он
//работает быстрее, чем контейнер vector, и потребляет меньше памяти.
//При объявлении переменной этого типа необходимо явно задавать размер контейнера:
//  std::array<int, 3> a = {1,2,3};
//std::array имеет ограниченное количество методов, так как не позволяет изменять количество элементов
//  at(index) - возвращает ссылку на элемент по индексу
//  operator[index] - возвращает ссылку на элемент по индексу
//  data() - возвращает указатель на блок памяти, в котором хранятся данные
//  front() - возвращает ссылку на первый элемент контейнера
//  back() - возвращает ссылку на последний элемент контейнера
//  empty() - возвращает true, если размер контейнера равен 0
//  size() - возвращает количество элементов контейнера
//  swap(array1) - обменивает содержимое с другим std::array

//std::array поддерживает двунаправленные итераторы:
// begin(), cbegin() - возвращает итератор на первый элемент контейнера
// end(), cend() - возвращает концевой итератор на элемент, следующий за последним
// rbegin(), crbegin() - возвращает обратный итератор на элемент, предшествующий первому
// rend(), crend() - возвращает обратный итератор на последний элемент контейнера

//Адаптеры контейнеров - std::stack
//---------------------------------

//Это стек или "стопка", контейнер, реализующий концепцию LIFO - last in, first out.
//То есть элемент, положенный в стопку первым, покинет ее последним.
//Контейнер поддерживает только добавление и удаление элемента с верха стопки
//(с конца стека) top(), push(), pop().

//Адаптеры контейнеров - std::queue
//---------------------------------

//Это очередь, контейнер, реализующий концепцию FIFO - first in, first out.
//Элемент, попавший в очередь первым, первым ее и покинет.
//  front() - доступ к первому элементу
//  back() - доступ к последнему элементу
//  push() - добавление элемента в конец очереди
//  pop() - удаление элемента из начала очереди

//Адаптеры контейнеров - std::priority_queue
//------------------------------------------

//Это та же очередь, но каждому элементу присваивается еще и его "ценность". Таким образом,
//метод top() вернет не первый добавленный элемент, а элемент с наибольшей ценностью.


///Эффективность последовательных контейнеров.
/*Выбор контейнера основывается на цели его использования. Поэтому необходимо знать,
  насколько эффективно класс контейнера реализует те или иные операции.

                Вставка (начало / конец)  Удаление (начало / конец) Доступ
  vector        O(n) / O(1)               O(n) / O(1)               O(1)
  list          O(1)                      O(1)                      O(n), O(1) из начала или конца
  forward_list  O(1)                      O(1)                      O(n), O(1) из начала
  deque         O(1) / O(1)               O(1) / O(1)               O(n)
  array         -                         -                         O(1)

*/

//Задания:
//1. Дан список строк L и список чисел P. P отсортирован в возрастающем порядке
//   и содержит индексы строк из L. Написать функцию printList, печатающую строки из
//   списка L, индексы которых заданы списком P. Какова сложность функции?
//1.1. Реализуйте ту же функцию, но уже для векторов L и P.
//1.2. Реализуйте ту же функцию, но используя алгоритмы STL.

//2. Даны два отсортированных списка L1 и L2. Напишите функцию, возвращающую L1∩L2.
//2.1. Напишите ту же функцию, но для двух отсортированных векторов.

//3. Даны два отсортированных списка L1 и L2. Напишите функцию, возвращающую L1∪L2.
//3.1. Напишите ту же функцию, но для двух отсортированных векторов.

///-----------------------------------------------------------------------------
///  Ассоциативные контейнеры                                                  |
///-----------------------------------------------------------------------------

#include <map>
#include <set>

//Ассоциативный контейнер хранит свои элементы в виде связанных пар <ключ, значение>.
//При этом типом ключа и значения может быть практически любой тип C++.

///  map

// Класс map хранит пары <ключ, значение>, используя вспомогательный класс std::pair,
//при этом ключи в map упорядочены лексикографически. Таким образом, тип ключа должен
//поддерживать оператор <.
//Контейнер map может содержать только одно значение с определенным ключом, то есть тип
//ключа должен поддерживать оператор ==.




void useMap()
{
    //map - шаблонный класс, поэтому при объявлении переменной типа map необходимо указать
    //типы ключа и значения.
    std::map<int,std::string> m;

    //можно сразу при объявлении переменной инициализировать её списком значений:
    std::map<int, double> m1 {{1,10.0}, {2,23.6}};

    //а можно добавлять элементы по одному при помощи оператора []
    m[0]="first";
    m[3]="second";
    m[-2]="third";
    //или с помощью метода
    m.insert({1, "string"});

    //Необходимо помнить, что элементы, помещаемые в map, и извлекаемые из него, представляют
    //собой объекты класса std::pair:
    //1. итераторы, определенные в классе map, возвращают указатели на объекты pair
    //2. вставка элементов осуществляется вставкой объекта типа pair
    m.insert(std::make_pair<int, std::string>(10,"ten"));
    //запись выше - это лишь сокращенная форма, допускаемая в новых версиях C++.

    //Другие методы:
    //m.at(key) - возвращает ссылку на значение для ключа key. Если такого элемента нет, будет брошено исключение.
    //m[key] - возвращает ссылку на значение для ключа key. Если такого элемента нет, то он будет создан.
    //iterator = m.find(key) - ищет элемент с ключом key  и возвращает итератор на этот элемент,
    //    если элемент найден, и map.end(), если элемент не найден.
    //m.clear() - удаляет всё содержимое
    //m.erase(key) - удаляет элемент с ключом key
    //m.erase(iter) - удаляет элемент, на который указывает итератор iter
    //m.size() - возвращает количество элементов
    //m.empty() - возвращает true, если контейнер пуст
    //m.count(key) - возвращает количество элементов с ключом key, то есть 0 или 1
    //m.lower_bound(key) - возвращает итератор на первый элемент, ключ которого не меньше значения key
    //m.upper_bound(key) - возвращает итератор на первый элемент, ключ которого больше значения key

    //Итераторы:
    //m.begin() - итератор, указывающий на первый элемент
    //m.end() - итератор, указывающий на элемент за последним
    //m.rbegin() - итератор, указывающий на последний элемент
    //m.rend() - итератор, указывающий на элемент перед первым.
}

///  multimap

//В том же заголовочном файле <map> определен класс multimap, который позволяет хранить
//в одном контейнере элементы с совпадающими ключами. Использование его полностью аналогично
//использованию map, однако метод count(key) может вернуть число, большее 1.

///  set

//В заголовочном файле <set> определен класс set, позволяющий хранить элементы определенного
//типа в лексикографическим порядке (в отличие от vector, хранящем элементы в порядке
//добавления). Этот контейнер не допускает дублирование хранимых элементов.
//Класс multiset допускает дублирование элементов.

void useSet()
{
    std::set<std::string> words;
    words.insert("first");
    words.insert("second");
    words.insert("third");
    words.insert("first"); //размер множества равен 3, хотя вставок было 4.
}

//Задания
//1. Напишите функцию, которая сортирует вектор целых чисел, попутно удаляя повторяющиеся элементы.
//   Используйте std::set для отслеживания неповторяющихся элементов.

#endif // STL_CONTAINERS_H
