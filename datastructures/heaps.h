#ifndef HEAPS_H
#define HEAPS_H

#include <vector>

/*
При решении практических задач часто требуется выстроить задачи, поступающие на вход системы,
в определенном порядке, чтобы выполнять их оптимальным способом. То есть нам нужна такая
структура данных, которая позволяла бы относительно дешево извлекать из нее наиболее подходящий
элемент. Такая структура данных называется куча (queue). (Более точно - очередь с приоритетом -
priority queue).

Интерфейс очереди должен поддерживать только две операции - вставка элемента и извлечение
минимального элемента. Некоторые реализации поддерживают еще одну операцию - поиск
минимального элемента без его извлечения.

Существует несколько реализаций очереди. Наиболее простая - использовать связный список,
и всегда вставлять элементы за O(1). Тогда поиск минимального элемента будет иметь
сложность в общем случае O(N). Если поддерживать такой список всегда отсортированным, то
вставка элемента потребует поиска места вставки, то есть будет иметь сложность O(N),
но извлечение минимального элемента упростится до O(1).

Еще одна реализация использует двоичные деревья. Для них среднее время как вставки,
так и извлечения элемента равно O(log N).
Логика здесь простая - в бинарном дереве все элементы из левой ветки меньше элемента
в узле, все элементы в правой ветке больше элемента в узле. Вставка элемента
требует перестройки дерева, и занимает в среднем O(log N).
В худшем случае получаем дерево с единственной веткой, тогда вставка будет линейна - O(N).
Поиск элемента в дереве занимает O(log N).

Можно реализовать очередь в виде полного двоичного дерева. Но тогда мы получим,
во-первых, накладные расходы на поддержание такого дерева, во-вторых, лишний код.

Более распространена версия двоичного дерева, позволяющая "сплющить" его до одномерного вектора.
Она называется куча (или двоичная куча) и умело использует свойства двоичного дерева поиска.
Фактически, название "двоичная куча" стало практически синонимичным названию "очередь
с приоритетом".

Куча - это двоичное дерево, все уровни которого (за исключением, возможно, самого нижнего)
полностью заполнены. Легко показать, что куча высотой h будет иметь от 2^h до 2^(h+1)-1
элементов. Элементы в куче расположены настолько регулярно, что можно показать, что
любую кучу можно представить в виде вектора, причем для элемента в позиции i (i>0) левый потомок
будет иметь индекс 2i, правый потомок - 2i+1, родитель - i/2 (целая часть от деления).
Элемент с индексом 0 используется как служебный. Тогда корень дерева будет расположен по индексу 1.
Тогда такое дерево можно представить в виде следующего массива:
        A
    B       C         A B C D E F G H I J
  D   E   F   G     0 1 2 3 4 5 6 7 8 9 10 11 12 13
 H I J

Листья такого дерева всегда будут расположены в правой части вектора, и будут занимать
⌈N/2⌉ позиций.

Можно уменьшить размер вектора, если переместить корень дерева в индекс 0. Тогда левый
потомок узла i будет иметь индекс 2i+1, правый - 2i+2, родитель - (i-1)/2.
*/

template <typename Comparable>
class BinaryHeap
{
public:
    explicit BinaryHeap( int capacity = 100 );
    explicit BinaryHeap( const std::vector<Comparable> & items );

    bool isEmpty( ) const {return currentSize==0;}
    const Comparable & findMin( ) const;

    int insert( const Comparable & x );
    void deleteMin( );
    void deleteMin( Comparable & minItem );
    void makeEmpty( );

private:
    int currentSize; // Number of elements in heap
    std::vector<Comparable> array; // The heap array

    void buildHeap( );
    void percolateDown( int hole );
    void percolateUp( int hole );
};

/*
Основное свойство кучи - это сбалансированность ее элементов. Если потребовать, чтобы
любой элемент был меньше своих потомков, тогда в корне кучи всегда будет находиться
минимальный элемент. Такое дерево называется min heap. Ее можно превратить в max heap,
если изменить порядок размещения элементов (любой элемент больше своих потомков).

Таким образом, поиск минимального элемента имеет сложность O(1). Однако, вообще говоря,
в куче невозможно достаточно эффективно определить индекс произвольного элемента за
достаточно эффективное время без просмотра всего вектора. Поэтому если требуется
поиск элемента, то используют вспомогательный хеш, в котором хранят индексы элементов
кучи. Метод insert в интерфейсе выше возвращает индекс вставляемого элемента в куче.

Вставка элементов

Чтобы вставить элемент, найдем для него ближайшее пустое место (конец вектора).
Если оно удовлетворяет условию кучи, то на этом вставка закончена. Если же элемент
меньше своего предка, то поменяем их местами. Будем менять местами элемент и его
предка до тех пор, пока элемент не встанет на свое место. Этот процесс называется
"просачиванием вверх" (percolate up). Например, вставим элемент 14 в следующую кучу:

             13                        13                          13
     21            16           21            16           [  ]         16
  24     31      19  68 ->   24    [  ]     19  68 ->   24     21     19  68
65  26 32  [ ]            65  26 32   31             65  26 32  31

Если вставляемый элемент - минимальный в куче, то он всплывет на самый верх
(то есть в индекс 1). Элемент с индексом 0 - это служебный элемент, в котором мы храним
копию вставляемого элемента.
*/

template <typename Comparable>
int BinaryHeap::insert( const Comparable & x )
{
    //Double the size of array of there is not enough space left
    if( currentSize == array.size( )-1)
        array.resize( array.size( ) * 2 );

    // Percolate up
    int hole = ++currentSize;
    Comparable copy = x;

    array[ 0 ] = std::move( copy );
    for( ; x < array[ hole / 2 ]; hole /= 2 )
        array[ hole ] = std::move( array[ hole /2]);
    array[ hole ] = std::move( array[ 0 ] );
    return hole;
}

/*
Извлечение минимального элемента

При удалении минимального элемента в корне кучи появляется дырка. Если ее можно заполнить
последним элементом кучи, то алгоритм завершен. Но такая ситуация встречается редко.
Поместим меньшего из потомков дырки в дырку, тем самым переместив дырку вниз на один уровень.
Будем повторять процесс, пока дырка не окажется на самом нижнем уровне кучи. Это процесс
называется "просачиванием вниз" (percolate down).

Удалим наименьший элемент из следующей кучи:

           [13]                       14                        14
      14          16            []          16            19          16
  19      21    19  68 ->   19      21    19  68 ->   []      21    19  68 ->
65  26  32  31            65  26  32  31            65  26  32  31

            14                        14
      19          16            19          16
  26      21    19  68 ->   26      21    19  68
65  []  32  31            65  31  32
*/

/**
 * Remove the minimum item.
 * Throws UnderflowException if empty.
 */
void BinaryHeap::deleteMin( )
{
    if(isEmpty( ) )
        throw UnderflowException{ };

    array[ 1 ] = std::move( array[ currentSize-- ] );
    percolateDown( 1 );
}

/**
 * Remove the minimum item and place it in minItem.
 * Throws UnderflowException if empty.
 */
void BinaryHeap::deleteMin( Comparable & minItem )
{
    if( isEmpty( ) )
        throw UnderflowException{ };

    minItem = std::move( array[ 1 ] );
    array[ 1 ] = std::move( array[ currentSize-- ] );
    percolateDown( 1 );
}

/**
 * Internal method to percolate down in the heap.
 * hole is the index at which the percolate begins.
 */
void BinaryHeap::percolateDown( int hole )
{
    int child;
    Comparable tmp = std::move( array[ hole ] );

    for( ; hole * 2 <= currentSize; hole = child )
    {
        child = hole * 2;
        if( child != currentSize && array[ child +1]<array[ child ] )
            ++child;
        if( array[ child ] < tmp )
            array[ hole ] = std::move( array[ child ] );
        else
            break;
    }
    array[ hole ] = std::move( tmp );
}

void BinaryHeap::percolateUp(int hole)
{
    T x = array[hole];

    array[ 0 ] = std::move( x );
    for( ; x < array[ hole / 2 ]; hole /= 2 )
        array[ hole ] = std::move( array[ hole /2]);
    array[ hole ] = std::move( array[ 0 ] );
}

/*
Построение кучи

Построение кучи из имеющегося набора элементов может быть осуществлено поочередным
вызовом метода insert. Но такая вставка N элементов потребует N вызовов метода insert,
каждый вызов имеет среднюю сложность O(1), вплоть до O(log N) в наихудшем случае.
Таким образом, построение кучи будет иметь сложность O(N log N) в худшем случае.

Поступим иначе: возьмем исходный вектор элементов и будем рассматривать его как кучу.
Теперь необходимо перестроить кучу, чтобы восстановить её структуру. Для этого применим
метод percolateDown к элементам вектора. Для его правильной работы необходимо, чтобы
все потомки элемента уже были перколированы. Очевидно, листья дерева перколировать
не требуется, так как ниже них ничего нет. Поэтому работу начинаем с середины
вектора, двигаясь к началу. Нам достаточно обработать половину элементов, так как
конечные элементы (листья) любого бинарного дерева занимают ровно половину вектора.
*/

explicit BinaryHeap::BinaryHeap( const vector<Comparable> & items )
    : array( items.size( ) + 10 ), currentSize{ items.size( ) }
{
    for( int i = 0; i < items.size( ); ++i )
        array[ i+1]=items[ i ];
    buildHeap( );
}

explicit BinaryHeap::BinaryHeap( int capacity)
    : array(capacity), currentSize{0}
{

}

/**
 * Establish heap order property from an arbitrary
 * arrangement of items. Runs in linear time.
 */
void BinaryHeap::buildHeap( )
{
    for( int i = currentSize / 2; i > 0; --i )
        percolateDown( i );
}

const BinaryHeap::Comparable & findMin( ) const
{
    if( isEmpty( ) )
        throw UnderflowException{ };
    return array[1];
}

#endif // HEAPS_H
