#ifndef RANDOM_H
#define RANDOM_H

#include <random>
#include <ctime>
#include <iostream>

void simpleRandom()
{
    //Пример генерации случайного числа с помощью функции rand (из языка С)

    //задаем значение зерна (seed) генератору случайных чисел - обязательно при использовании функции rand.
    //Значение зерна равно текущему системному времени, то есть при каждом запуске программы
    //значение зерна будет меняться.
    srand(std::time(nullptr));
    //Зерно нужно, чтобы функция rand возвращала разные случайные числа при каждом запуске программы.
    //Ниже написано подробнее.

    //Функция rand возвращает случайные числа, равномерно распределенные в диапазоне [0, RAND_MAX]
    //Значение RAND_MAX зависит от компилятора, но обычно равно 32767
    //int r = rand(); //сгенерировали случайное число

    //лямбда-функция, принимающая целое число r и верхнюю границу диапазона [0, n)
    //и возвращающая число, преобразованное к этому диапазону
    auto bounded = [](int r, unsigned int n){
        if (n > 0)
            return int(r % n);
        return 0;
    };

    int vec[4]; //вектор случайных чисел в диапазоне [0, 100)
    //заполняем вектор
    for (int i=0; i<4; ++i)
        vec[i] = bounded(rand(), 100);

    //Функция rand() имеет серьезные недостатки: 1. Она возвращает не настоящее случайное число,
    //а т.н. псевдослучайное - при одинаковом значении зерна (передаваемого в функцию srand())
    //мы всегда будем получать одинаковые псевдослучайные числа.
    //2. Функция rand всегда возвращает целое число из диапазона [0, RAND_MAX], распределенное равномерно.
    //Если требуется иной диапазон, или иной закон распределения, то нужно писать обертки над rand().
    //Выше функция bounded преобразует псевдослучайное число к требуемому диапазону.
}

//C++ предоставляет удобную библиотеку <random> для работы со случайными числами.
//Библиотека позволяет использовать различные генераторы псевдослучайных или настоящих случайных чисел,
//задавать тип генерируемого случайного числа (int, double, short и т.д.),
//выбирать закон распределения случайных чисел (равномерное, нормальное, Пуассона и т.д.)
//выбирать диапазон случайных чисел.

//Функция генерирует случайное целое число из диапазона [min, max]
int generateUniformInt(int min, int max)
{
    //Вначале необходимо выбрать зерно (seed) для генератора случайных чисел.

    //Мы используем генератор настоящих случайных чисел std::random_device для получения seed.
    //Генератор настоящих случайных чисел отличается от генератора псевдослучайных чисел тем,
    //что использует случайные неконтролируемые флуктуации в работе железа компьютера (процессора,
    //оперативной памяти, случайные нажатия клавиш клавиатуры или мыши), то есть в результате
    //мы получаем настоящее случайное число, связанное с физическим миром, а не с алгоритмами компьютера.
    std::random_device seeder;
    const auto seed = seeder.entropy() ? seeder() : std::time(nullptr);

    //Так как генератор std::random_device работает очень медленно, обычно он используется
    //только когда необходимо гарантировать генерацию криптографически стойких случайных чисел.
    //В нашем случае мы воспользуемся генератором std::random_device только один раз, для получения зерна.
    //А дальше мы будем использовать простой генератор псевдослучайных чисел std::default_random_engine,
    //инициированный этим зерном, для генерации всех остальных случайных чисел. Такой генератор
    //работает очень быстро и генерирует случайные числа более высокого качества, чем функция rand.
    std::default_random_engine g(static_cast<std::default_random_engine::result_type>(seed));

    //создаем генератор равномерного распределения, который будет пребразовывать
    //случайное число, полученное из g.
    std::uniform_int_distribution intDistrib(min, max); //явно указываем равномерное распределение

    //передаем в генератор равномерного распределения генератор случайных чисел g
    return intDistrib(g); //генерируем требуемое значение

    //Или можно заполнить вектор случайными числами:
    std::vector<int> vec;
    for (int i=0; i<100; ++i) vec.push_back(intDistrib(g)); //вектор из 100 случайных чисел

    //Если нужно получить вещественное случайное число, то можно использовать другое распределение:
    std::uniform_real_distribution<double> realDistrib(min, max);

    //Если нужно не равномерное распределение, а нормальное (Гаусса), то используем следующий тип:
    double mean = 2.0; //задаем мат.ожидание μ
    double stddev = 0.5; //задаем стандартное отклонение σ²
    std::normal_distribution<double> normalDistrib(mean, stddev);
    //Другие распределения, основанные на нормальном:
//    lognormal_distribution<Real = double>(Real mean = 0.0, Real stddev = 1.0) - логарифмическое нормальное
//    chi_squared_distribution<Real = double>(Real degrees_of_freedom = 1.0) - χ²
//    cauchy_distribution<Real = double>(Real peak_location = 0., Real scale = 1.) - Коши
//    fisher_f_distribution<Real = double>(Real dof_num = 1., Real dof_denom = 1.) - Фишера
//    student_t_distribution<Real = double>(Real degrees_of_freedom = 1.0) - Стьюдента


    //Распределения, основанные на распределении Пуассона:
//    poisson_distribution<Int = int>(double mean = 1.0)
//    exponential_distribution<Real = double>(Real lambda = 1.0)
//    gamma_distribution<Real = double>(Real alpha = 1.0, Real beta = 1.0)
//    weibull_distribution<Real = double>(Real a = 1.0, Real b = 1.0)
//    extreme_value_distribution<Real = double>(Real a = 0.0, Real b = 1.0)

    //Распределения, основанные на распределении Бернулли:
//    генерирует случайное булево значение true с вероятностью p и false с вероятностью 1-p
//    bernoulli_distribution(double p = 0.5)
//    генерируют случайное неотрицательное целое число согласно функции плотности вероятностей
//    binomial_distribution<Int = int>(Int t = 1, double p = 0.5) - биномиальное распределение
//    negative_binomial_distribution<Int = int>(Int k = 1, double p = 0.5) - ?
//    geometric_distribution<Int = int>(double p = 0.5) - геометрическое распределение

    //Дискретные распределения
//  Дискретное распределение требует count весовых значений, соответствующих вероятности выпасть
//  числу из диапазона [0, count)
//    discrete_distribution<Int = int>() - weight = 1.0
//    discrete_distribution<Int = int>(InputIt first, InputIt last) - принимает два итератора на вектор весов
//    discrete_distribution<Int = int>(initializer_list<double> weights) - принимает вектор весов
//    discrete_distribution<Int = int>(size_t count, double xmin, double xmax, UnaryOperation op)
//    веса генерируются функцией op по формуле
//         weight_i = op(xmin + i*δ + δ/2), где δ = (xmax-xmin)/count

    //Кусочно-константное распределение

    //Кусочно-линейное распределение

}


#endif // RANDOM_H
