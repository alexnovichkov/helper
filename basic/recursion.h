#ifndef RECURSION_H
#define RECURSION_H

#include <iostream>

//Если говорить просто - рекурсия - это вызов функции внутри этой же функции.

//При решении задач стандартная тактика - разбить общую задачу на ряд подзадач.
//Если при этом одна из подзадач представляет собой уменьшенную "копию" исходной задачи,
//то мы имеем дело с рекурсией.

//Пример: Пусть нам требуется решить задачу вывода целого неотрицательного числа вертикально:
//1
//9
//8
//4
//Решение: разобъем задачу на подзадачи.
//1. Если число состоит только из одной цифры, то просто выводим эту цифру на экран.
//2. Если мы уже вывели все цифры, кроме последней, то выводим последнюю цифру.
//Последняя цифра - это остаток от деления на 10. Все цифры, кроме последней - это
//результат деления на 10. Таким образом, мы имеем следующий алгоритм:

void printVertically(int number)
{
    if (number<10) //число меньше 10
        std::cout << number << std::endl;
    else {//рекурсивная часть алгоритма
        printVertically(number/10); //выводим число без последней цифры
        std::cout << number % 10 << std::endl;
    }
}
1984 -> (198)4 -> ((19)8)4 -> (((1)9)8)4
//Проследим, как работает алгоритм, на примере числа 123. Для этого рекурсивно будем применять
//функцию printVertically к числу 123

//первая итерация
void printVertically1(/*number = 123*/)
{
    if (123 < 10) //эта ветка не выполнится
        std::cout << 123 << std::endl;
    else {//рекурсивная часть алгоритма
        printVertically(123 / 10); //выводим число 123 без последней цифры, то есть 12
        std::cout << 123 % 10 << std::endl; // выводим последнюю цифру, то есть 3
    }
}

//вторая итерация
void printVertically2(/*number = 123*/)
{
    if (123 < 10) //эта ветка не выполнится
        std::cout << 123 << std::endl;
    else {//рекурсивная часть алгоритма
        if (12 < 10) //эта ветка не выполнится
            std::cout << 12 << std::endl;
        else {//рекурсивная часть алгоритма
            printVertically(12 / 10); //выводим число 12 без последней цифры, то есть 1
            std::cout << 12 % 10 << std::endl; // выводим последнюю цифру, то есть 2
        }
        std::cout << 123 % 10 << std::endl; // выводим последнюю цифру, то есть 3
    }
}

//третья итерация
void printVertically3(/*number = 123*/)
{
    if (123 < 10) //эта ветка не выполнится
        std::cout << 123 << std::endl;
    else {//рекурсивная часть алгоритма
        if (12 < 10) //эта ветка не выполнится
            std::cout << 12 << std::endl;
        else {//рекурсивная часть алгоритма
            if (1 < 10) //эта ветка выполнится
                std::cout << 1 << std::endl; //осталась одна цифра
            else {//рекурсивная часть алгоритма, не выполнится
                printVertically(1 / 10);
                std::cout << 1 % 10 << std::endl;
            }
            std::cout << 12 % 10 << std::endl; // выводим последнюю цифру, то есть 2
        }
        std::cout << 123 % 10 << std::endl; // выводим последнюю цифру, то есть 3
    }
}

//Теперь если мы проследим ветвление последней итерации, мы получим следующую 
//последовательность инструкций:
void printVerticallyUnravelled()
{
    std::cout << 1 << std::endl;
    std::cout << 12 % 10 << std::endl;// выводим последнюю цифру, то есть 2
    std::cout << 123 % 10 << std::endl;// выводим последнюю цифру, то есть 3
}

//Конечно, компилятор не "разворачивает" рекурсивные вызовы функции в подобный код. 
//Он просто останавливает выполнение функции, так как чтобы продолжить, он должен 
//знать результат выполнения рекурсивно вызываемой функции. Компилятор помещает 
//вызов вложенной функции на стек, затем, после завершения этой функции, он возобновляет 
//выполнение внешней функции. Это можно изобразить следующей схемой:

//начало выполнения printVertically(123)
//остановка для рекурсивного вызова
//    начало выполнения printVertically(12)
//    остановка для рекурсивного вызова
//        начало выполнения printVertically(1) <- этот вызов не приведет к рекурсивному вызову
//        конец выполнения printVertically(1)
//    конец выполнения printVertically(12)
//конец выполнения printVertically(123)

//В нашем примере при вызове printVertically(1) дальнейших вызовов функции printVertically 
//не произойдет, так как мы достигли граничного условия (граничной ветки программы) 
//if (number < 10) std::cout << number << std::endl;
//Если в программе не прописано граничное условие, или прописано с ошибками, то 
//вызов функции приведет к бесконечной рекурсии - программа не сможет остановиться 
//и зависнет или потребит всю доступную память.

//Пример отсутствующего граничного условия, в котором функция будет вызывать себя бесконечно.
void newPrintVertically(int number)
{
    newPrintVertically(number / 10);
    std::cout << (number % 10) << std::endl;
}

//Еще один классический пример рекурсивной функции - вычисление факториала числа
//n! = 1*2*3*4*...*n
//В этом примере мы вычисляем факториал "с конца".
int factorial(int n)
{
    if (n==1) return n;
    return n * factorial(n-1);
}

//Задачи:
//1. Выпишите все числа, которые будут выведены в консоль в следующем фрагменте кода:
void F(int n)
{
    if (n>2) {
        std::cout << n << " ";
        F(n-2);
        F(n-3);
    }
}
F(9);

//9 7 5 3 4 6 4 3

//2. Напишите функцию, которая принимает положительное целое число и выводит на экран
//   строку символов * длиной, равной этому числу.
//3. Напишите функцию, которая принимает положительное целое число и выводит его
//   в обратном порядке: backwards(123) -> 321
//4. Напишите функцию, которая принимает положительное целое число n, и выводит числа
//   от 1 до n через запятую.

//Как уже упоминалось, программа помещает вызовы рекурсивной функции в стек вызовов.
//Стек вызовов - это структура в оперативной памяти, похожая на стопку бумаги.
//Перед вызовом функции стек - стопка - пуст. При первом вызове функции в стек помещается
//первый лист. Когда программа доходит до следующего вызова функции, на верх стопки помещается
//второй лист, а выполнение первого листа приостанавливается - он скрыт вторым листом.
//При последующих рекурсивных вызовах функции стопка листов растет, пока программа не дойдет
//до граничного условия. Это значит, что самый последний вызов функции закончен,
//и можно удалить верхний лист из стопки. Выполнение переходит к предпоследнему листу.
//И так далее, пока в стеке есть вызовы функции.

//Таким образом, если в функции не прописано граничное условие, то стек будет расти
//бесконечно, а так как стек вызовов имеет конечный размер, то в определенный момент
//произойдет переполнение стека (stack overflow).


//Не всегда рекурсия нужна. Многие рекурсивные алгоритмы можно переписать с помощью цикла,
//то есть последовательного выполнения одинаковой порции кода.
//Обычно рекурсивная версия алгоритма выглядит проще, но работает медленнее и требует больше памяти,
//за счет необходимости сохранять состояние вызовов функции в стеке.

//Пример: нерекурсивный вариант вычисления факториала
int factorialNonRecursive(int n)
{
    int result = 1;
    for (int i=2; i<=n; ++i) result *= i;
    return result;
}

//Задача:
//5. Перепишите функцию printVertically, реализуя ее нерекурсивный вариант

//При написании рекурсивной функции соблюдайте следующие три правила:
//1. Убедитесь, что вызов функции не приведет к бесконечной рекурсии, то есть к вызову
//функции с одним и тем же аргументом.
//2. Убедитесь, что в функции прописано граничное условие, которое не приводит к последующим
//вызовам рекурсивной функции, то есть что граничное условие действительно завершит рекурсивные вызовы.
//3. Убедитесь, что любой рекурсивный вызов в конечном счете приведет к граничному условию.

//Пример построения рекурсивного алгоритма: бинарный поиск
//--------------------------------------------------------

//Предположим, что у нас есть отсортированный вектор каких-либо значений. Пусть для простоты
//это будут целые числа. Отсортированный - значит, все элементы расположены по неубыванию:
//a[0] <= a[1] <= a[2] <= ... <= a[n-1]
//Алгоритм бинарного поиска подразумевает поиск конкретного элемента в этом векторе,
//то есть получение его индекса. Мы можем просто перебрать все элементы вектора один за другим,
//пока не наткнемся на искомый элемент. Однако гораздо выгоднее использовать тот факт,
//что вектор отсортирован.
//Возьмем произвольный элемент a[i] из середины вектора. Если этот элемент больше искомого,
//то очевидно, что искомый элемент находится левее a[i]. Если a[i] меньше искомого,
//то искомый элемент расположен в правой части вектора - правее a[i].
//Если же a[i] равен искомому, то мы нашли то, что требовалось.
//Таким образом, взяв произвольный элемент из вектора, мы сразу можем отбросить из рассмотрения
//правую или левую часть вектора. Удобно делить вектор пополам - поэтому алгоритм называется
//бинарный поиск.
//Теперь, отбросив одну половину, мы можем повторить те же операции с оставшейся половиной,
//то есть мы свели алгоритм к нему же, только с меньшим количеством элементов в векторе.
//Что если в векторе отсутствует искомый элемент? Нам нужно некое граничное условие.
//Логично выбрать граничным условие, при котором в векторе осталось меньше 2 элементов -
//дальше делить вектор не имеет смысла.
//Чтобы упростить реализацию алгоритма, можно переформулировать условие "в векторе остался
//единственный элемент" в терминах индексов элементов:
// 1 3 6 12 30 31 44 56
// |                 |
//first             last
//Длина вектора равна 8 - first=1, last=8 - в векторе все элементы
// 1 3 6 12 30 31 44 56
//       |           |
//      first       last
//Передвинули first на три позиции вперед - расстояние между ними равно 4 - в векторе 4 элемента
// 1 3 6 12 30 31 44 56
//       |  |
//     last first
//first > last - расстояние между ними < 0 - "в векторе не осталось элементов"


//Алгоритм бинарного поиска полностью аналогичен тому, как мы ищем слово в словаре -
//ищем примерное положение слова, перелистывая страницы вперед или назад.

//Псевдокод для бинарного поиска - первое приближение
//int a[n] - исходный вектор
//int x - искомое число
//first=0, last=n-1 - указывают на первый и последний элементы вектора
//если first >= last - граничное условие - в векторе не осталось элементов
//    mid = индекс в середине вектора
//    если a[mid] == x - нашли элемент
//    иначе если x < a[mid] - x расположен в левой половине
//        повторяем поиск от first до mid-1
//    иначе если x > a[mid] - x расположен в правой половине
//        повторяем поиск от mid+1 до last

int binarySearch(int a[], int first, int last, int x)
{
    if (first > last) return -1; //отрицательный индекс - элемент x не найден

    int mid = (first + last)/2; //середина диапазона
    if (a[mid]==x) return mid; //нашли элемент в позиции mid
    else if (a[mid]>x) return binarySearch(a, first, mid-1, x); //повторяем поиск в левой половине
    else if (a[mid]<x) return binarySearch(a, mid+1, last, x); //повторяем поиск в правой половине

    return -1; //ничего не нашли
}

//эта функция использует рекурсивный вариант, написанный выше, и предоставляет
//удобный интерфейс для использования
int binarySearch(int a[], int n, int x)
{
    return binarySearch(a, 0, n-1, x);
}

//Задание:
//6. Оцените эффективность алгоритма бинарного поиска: сколько сравнений потребуется выполнить
//   при простом переборе элементов вектора длиной 100? Дайте минимальное и максимальное количество сравнений.
//   Сколько сравнений потребуется при бинарном поиске в векторе длиной 100? длиной 1000?

//7. Перепишите алгоритм бинарного поиска так, чтобы он не использовал рекурсию
//   (совет: используйте граничное условие в качестве условия цикла while)

//Задания:
//8. Напишите рекурсивную функцию, вычисляющую сумму квадратов чисел от 1 до N.
//9. В комнате N человек. Напишите рекурсивную функцию, возвращающую количество рукопожатий
//   этих человек. Каждый человек жмет руку всем остальным.
//   Граничные условия: handshake(1) = 0, handshake(2)=1
//10. Шоколадный батончик стоит 1$. В каждом батончике есть купон на 1/7 батончика, то есть
//    собрав 7 купонов, можно купить еще один батончик. Напишите функцию, возвращающую
//    общее количество батончиков, которые можно съесть на N долларов.
//11. Написать функцию, которая вычисляет все возможные перстановки символов в строке.
//    Совет: перестановки в строке из n символов можно получить, если взять первый символ в строке
//    и подставить его во все возможные места для каждой перестановки из 2..n символов.
//12. Для данного набора символов (строки) и числа k вывести все возможные строки длиной k
//    из данного набора символов (символы могут повторяться)
//13. Напишите функцию, которая вычисляет количество гласных в строке.
//14. Для данных чисел n и k > 0 вывести все возрастающие последовательности из k чисел,
//    таких, что числа не превышают n.
//    Например, для k=3, n=3: 12,13,23
//                  k=3, n=5: 123,124,125,134,135...
//15. Напишите функцию, возвращающую максимальный элемент в векторе.
//16. Для заданного вектора целых чисел вывести пирамиду сумм соседних элементов:
//            48
//         20   28
//       8   12  16
//     3   5   7   9
//   1   2   3   4   5
//17. Для заданного числа n вывести на экран последовательность вида
//    n, n-5, n-10,...0...n-10, n-5
//    (вместо нуля может быть отрицательное число)
//18. Для заданного вектора чисел вывести все возможные суммы подпоследовательностей
//    (включая подпоследовательности длиной 1). Например, для вектора
//    {1, 5, -2} : 1, 5, -2, 6, -1, 3, 4


#endif // RECURSION_H
