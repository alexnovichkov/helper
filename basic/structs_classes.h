#ifndef OOP_H
#define OOP_H

#include <iostream>
#include <vector>

using namespace std;

/**
  В этом файле приведены примеры использования структур и классов C++
  */

//Классы и структуры - это типы данных, которые позволяют агрегировать внутри себя
//другие данные и функции для обработки этих данных

//Терминология:
//Класс - это тип данных
//Объект - это переменная, тип которой - тот или иной класс
//Член класса - функция или переменная, содержащаяся в классе

//1. СТРУКТУРЫ

//Структура (struct) - это коллекция переменных и функций для их обработки, объединенных
//одним именем. В простейшем случае структура не включает никаких функций-членов, только данные

struct CompactDisc {
    int lengthInSeconds;
    string artist;
    vector<string> tracks; 
    //оператор сравнения, который используется для сравнения объектов одного типа
    bool operator==(const CompactDisc &other)
    {
        //попарно сравниваем переменные-члены структуры
        return lengthInSeconds == other.lengthInSeconds
                && artist == other.artist
                && tracks == other.tracks;
    }
    CompactDisc operator=(const CompactDisc &other)
    {

    }
};

//Использование структуры:
void structUse()
{
    //Объявление объекта структуры
    CompactDisc cd;

    //Обращение к переменным-членам объекта происходит через точку
    cd.lengthInSeconds = 2500;
    cd.artist = "Madonna";
    cd.tracks.push_back("track1");

    //Если объект создан динамически, то доступ к членам объекта осуществляется
    //через оператор ->
    CompactDisc *cd1 = new CompactDisc;
    cd1->lengthInSeconds = 3400;
    //или через разыменование указателя на объект
    (*cd1).artist = "Bjork";
    delete cd1;

    //Объявление и инициализация с помощью списка
    CompactDisc cd2 {3450, "Fonsi", {"track1", "track2", "track3"}};

    //Присваивание данных другого объекта
    cd = cd2;

    //Сравнение объектов возможно, если мы добавим фукнцию-член структуры, переопределяющую
    //оператор сравнения (см. выше в объявлении структуры)
    bool equal = cd==cd2;
}

//2. КЛАССЫ

//Класс - это та же структура, но с дополнительным функционалом. Технически структура и класс
//не отличаются друг от друга - с небольшими изменениями объявление структуры можно
//переделать в объявление класса и наоборот.

//Обычно структуры используют там, где нужно просто объединить несколько переменных
//разных типов в одну логическую единицу.
//Классы используют тогда, когда требуется добавить сложное поведение объекта класса

class Date
{
//Всё, что объявлено в классе, по умолчанию является private, то есть доступно только
//внутри класса. Слово public: говорит, что мы хотим, чтобы следующие за ним члены можно
//было использовать в программе
public:
    //Конструкторы - это функции-члены класса, которые используются для создания
    //объектов класса. Они всегда имеют имя, совпадающее с именем класса.

    //Конструктор по умолчанию - вызывается при объявлении переменной без аргументов.
    //Члены класса имеют начальные значения, указанные в объявлении класса (ниже)
    Date() {
        //ничего не делаем - начальные значения членов класса уже известны
    }

    //Деструктор класса
    ~Date() = default;

    //Конструктор объекта с параметрами - вызывается, если мы хотим создать определенную дату
    //слово explicit говорит компилятору, что объект должен создаваться только через конструктор такого вида,
    //Сравни: std::string = "abcde";
    explicit Date(int year, int month, int day)
        : year{year}, month{month}, day{day} //секция инициализации - присваиваем членам класса
                                             //значения параметров конструктора
    {
         //больше ничего не делаем
    }

    // Имплицитный конструктор (без слова explicit) позволяет инициализировать объект класса аргументом
    // конструктора
    Date(int year) {
        this->year = year;
    }
    // Теперь где-то в коде можно создать переменную d с помощью имплицитного конструктора
    //Date d = 8;

    //Функция-член класса, которую можно вызвать для любого объекта. Она объявлена как const,
    //так как при ее выполнении значения переменных-членов класса не изменяются.
    //ПРАВИЛО: Всегда делайте константными все функции, которые не меняют состояние объекта
    void print() const
    {
        std::cout << "Date("<<year<<","<<month<<","<<day<<")";
    }

    //Перегруженная функция, которая позволяет явно указать, куда мы выводим данные объекта
    void print(std::ostream &out) const
    {
        out << "Date("<<year<<","<<month<<","<<day<<")";
    }

    //Функция, которая изменяет значение одного из членов класса. Она не константная, так как
    //состояние объекта меняется
    void setYear(int year)
    {
        //слово this - это указатель на сам объект класса. Этот указатель доступен только внутри
        //функций-членов этого класса, и позволяет обратиться к любому члену. Здесь он используется,
        //чтобы отличить две переменные с одинаковым именем
        this->year = year;
    }

    //Функция, позволяющая получить значение переменной-члена класса. Здесь она объявлена как
    //const, так как не меняет значения переменных-членов класса.
    //Здесь значение переменной year копируется в новую переменную и возвращается из функции.
    int getYear() const
    {
        return year;
    }

    int getMonth() const {return month;}
    int getDay() const {return day;}
    void setMonth(int month) {this->month = month;}
    void setDay(int day) {this->day = day;}

    //Можно объявить функцию, позволяющую напрямую работать с переменными-членами класса
    //через ссылку на этот член. Это позволяет избежать лишнего копирования данных:
    int &directYear() //слово const отсутствует, так как мы явно хотим менять значение year
    {
        return year;
    }
    //Теперь можно работать напрямую с членом класса year:
    //d.directYear() += 4;

    //Это объявление статической функции-члена класса. Такие функции доступны даже без создания
    //объекта класса и позволяют вынести в отдельную функцию код, который не зависит от
    //значений переменных-членов класса
    static int daysInYear(int year)
    {
        //здесь идет определение количества дней в году в зависимости от того,
        //високосный год или нет.
        if (year % 4 == 0) {
            if (year % 100 == 0) {
                if (year % 400 == 0) return 366;
                else return 365;
            }
            else return 366;
        }

        return 365;
    }

//Слово private: говорит, что к объявленным дальше членам имеет доступ только сам класс
//Здесь слово private: используется как переключатель области видимости членов класса,
//так как выше мы использовали переключатель public:
private:
    int year = 0; //начальные значения для членов
    int month = 0;
    int day = 0;
    friend bool operator==(const Date & first, const Date & second);
//Переключатели можно использовать в любом порядке и в любом количестве
};

//

//Использование класса
void classUse()
{
    //Объявление переменной класса ничем не отличается от объявления переменной структуры
    Date d; //year = 0, month=0, day=0
    //Объявление с начальными значениями через конструктор
    Date d1(1220, 1, 23); //year = 1220, month = 1, day=23
    //Объявление через инициализацию списком
    Date d2 {1984, 10, 11}; //year = 1984, month = 10, day = 11
    //Объявление и инициализация копированием другого объекта
    Date d3=d1; //d2 теперь - копия d1
    Date d4{d1}; //то же, что и выше

    //вызываем функцию-член объекта
    d4.print();

    //Создание объекта в куче и обращение к членам объекта аналогично:
    Date *d5 = new Date(2020, 11, 18); //18 ноября 2020 года
    //d5->day = 19; //Запрещено: член day объявлен как приватный
    d5->setYear(2021); //OK, изменяем год, используя функцию-член класса
    d5->directYear() = 2022; //OK, напрямую меняем значение года, используя ссылку
    //...
    delete d5; //переменная d5 больше не нужна, освобождаем память

    //Обращение к статическим членам класса не требует создания объекта класса:
    int daysInThisYear = Date::daysInYear(2020); //daysInThisYear = 366;
    //Но можно использовать их и как обычные члены:
    int daysInYear = d1.daysInYear(2020);
}

//Перегрузка операторов и дружественные функции и классы
//------------------------------------------------------

//Выше в структуре CompactDisc мы определили оператор сравнения двух компакт-дисков в виде метода структуры.
//Но можно перегрузить оператор сравнения как функцию, внешнюю по отношению к структуре:

//bool operator==(const CompactDisc & first, const CompactDisc & second)
//{
//    return first.lengthInSeconds == second.lengthInSeconds
//            && first.artist == second.artist
//            && first.tracks == second.tracks;
//}

//Аналогично можно перегрузить любые операторы - булевы, арифметические, оператор new и т.д.

//Теперь перегрузим оператор сравнения для класс Date:
bool operator==(const Date & first, const Date & second)
{
    return first.getYear() == second.getYear()
            && first.getMonth() == second.getMonth()
            && first.getDay() == second.getDay();
}
//В этой функции происходит вызов шести функций для сравнения полей класса. Это накладно. Что если
//существовал бы способ напрямую обратиться к полям класса Date? Мы не можем сделать это сейчас,
//так как поля year, month, day объявлены приватными.
//Для решения этой проблемы сделаем перегруженный оператор сравнения "дружественным" для класса
//Date. Для этого добавим строчку в любой раздел класса Date:

//class Date
//{
//public:
//  все публичные члены класса
//  friend bool operator==(const Date & first, const Date & second);
//private:
//  int year;
//  int month;
//  int day;
//}

//Теперь перегрузим эффективный оператор сравнения для класс Date:
//bool operator==(const Date & first, const Date & second)
//{
//    return first.year == second.year
//            && first.month == second.month
//            && first.day == second.day;
//}

//Правила перегрузки операторов (дополнительно):
//1. Хотя бы один аргумент должен иметь тип класса, для которого перегружаем оператор.
//2. Перегруженный оператор может быть членом класса, а может - дружественной функцией.
//3. Нельзя создавать новые операторы. Можно лишь перегружать существующие.
//4. Нельзя менять количество аргументов, которые принимает оператор. Например, нельзя сделать
//   из бинарного оператора % унарный (принимающий один аргумент).
//5. Нельзя изменить приоритет операторов. Перегруженный оператор будет иметь тот же приоритет,
//   что и обычная версия оператора.
//6. Следующие операторы перегрузить нельзя: оператор точки (.), оператор пространства имен (::),
//   операторы .* и ?:
//7. Некоторые операторы (=, [], ->, () ) перегружаются немного иначе, чем описано выше.

//Чаще всего перегрузка операторов используется в обычных классах (не математических), чтобы упростить
//вывод данных класса в поток и чтение данных класса из потока.
//Для этого перегружают операторы << и >>. При этом первый агрумент операторов - объект потока (по ссылке),
//второй - выводимый или считываемый объект. Возвращать операторы должны ссылку на первый аргумент:

std::ostream & operator<<(std::ostream & str, const Date & date)
{
    str << date.getYear()<<date.getMonth()<<date.getDay();
    return str;
}

std::istream & operator>>(std::istream & str, Date & date)
{
    int year, month, day;
    str >> year >> month >> day;
    date.setYear(year);
    date.setMonth(month);
    date.setDay(day);
    return str;
    //конечно, всегда можно сделать эту функцию дружественной, чтобы не использовать методы getYear...
}



//Задания:
//1. Дополните класс Date следующими функциями:
//- функцией, проверяющей дату на валидность
//- аналогичной функцией, но сделайте ее статической
//- функцией, возвращающей название месяца на английском/русском
//- функцией, возвращающей количество дней в месяце (для февраля возвращайте 28)
//- функцией, возвращающей дату через заданное количество дней (оно может быть и отрицательным)
//- функцией, возвращающей количество дней между двумя датами
//  используйте сигнатуру int daysBetween(const Date& other);
//- аналогичной функцией, но сделайте ее статической:
//  static int daysBetween(const Date& date1, const Date& date2);
//- добавьте оператор сравнения двух дат по образцу структуры CompactDisc
//- добавьте оператор <, позволяющий определить, какая дата идет раньше.
//  Используйте сигнатуру bool operator<(const Date& other);
//- функцией pretty, возвращающей строку с датой в формате "5 мая 2018 г."

// Дополнительно:
//2. Хранить дату с помощью трёх чисел не очень удобно. Подумайте, как можно изменить класс 
//   Date, чтобы обойтись одним числом. Каким должен быть тип этого числа? Какую физическую
//   сущность будет выражать это число? Как определить год, месяц, день из этого числа?
//   По желанию реализуйте измененный класс.

#endif // OOP_H
