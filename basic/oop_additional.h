#ifndef OOP_ADDITIONAL_H
#define OOP_ADDITIONAL_H

#include <string>
#include <iostream>
#include <vector>

using namespace std;

/// В этом файле описываются продвинутые темы объектно-ориентированного программирования:
/// 1. Приватное и защищенное наследование
/// 2. Виртуальное наследование
/// 3. Абстрактные классы и интерфейсы
/// 4. Получение информации о классе на этапе выполнения программы
/// 5. Удаление методов из класса
/// 6. Запрет наследования и переопределения

// 1. Приватное и защищённое наследование
// --------------------------------------

// Наиболее часто встречается публичное наследование, при котором все публичные методы
// базового класса остаются публичными в производном классе:

class Base
{
public:
    virtual ~Base();
    void publicFunction();
protected:
    virtual void protectedFunction() = 0;
private:
    void privateFunction();
};

class Derived1 : public Base
{
public:
    void g() {
        publicFunction(); // OK
        protectedFunction(); // OK, вызывается переопределенный метод
        privateFunction(); // Ошибка! Приватный метод остался приватным
    }
protected:
    virtual void protectedFunction() override;
};

int main()
{
    auto d = new Derived1();
    d->publicFunction(); //OK
    d->protectedFunction(); // Ошибка! Метод остался защищенным
    d->privateFunction(); // Ошибка! Метод остался приватным
}

// При приватном наследовании публичные методы базового класса больше не доступны
// объектам производного класса, хотя в методах производного класса доступ сохраняется:

class Derived2 : private Base
{
public:
    void g() {
        publicFunction(); // OK
        protectedFunction(); // OK, вызывается переопределенный метод
        privateFunction(); // Ошибка! Приватный метод остался приватным
    }
protected:
    virtual void protectedFunction() override;
};

int main1()
{
    auto d = new Derived2();
    d->publicFunction(); // Ошибка! Из-за приватного наследования публичные методы стали приватными
    d->protectedFunction(); // Ошибка! Метод стал приватным
    d->privateFunction(); // Ошибка! Метод остался приватным
}

// Когда использовать приватное наследование? В большинстве случаев наследование используется
// для расширения функционала класса, тогда логично сохранить возможность объектам
// производного класса обращатся к базовому фунционалу базового класса через его публичные
// методы. В этом случае используется публичное наследование.

// В некоторых случаях, однако, требуется полностью изменить функционал базового класса,
// изменив его интерфейс. Этого можно добиться, скрыв публичные методы базового класса,
// и добавив новые в производном классе. В этом случае используется приватное наследование.
// Предположим, вы написали удобный класс Array, который используется как последовательный
// контейнер с контролем выхода за границы. У него есть методы добавления и удаления
// элементов в начало и конец массива push_back/pop_back, push_front/pop_front.
// Если теперь вам требуется использовать его как основу для класса Stack, интерфейс
// которого допускает доступ только к одному концу массива, логично скрыть стандартные
// методы и добавить свой интерфейс, состоящий только из двух методов push / pop.
// В этом случае приватное наследование поможет решить эту задачу.

// Если опустить модификатор public или private, то наследование по умолчанию публичное
// для структур и приватное для классов.

// Изредка используется защищённое наследование. При этом все публичные и защищённые
// методы базового класса становятся защищёнными в производном классе (приватные методы
// остаются приватными).


class Derived3 : protected Base
{
public:
    void g() {
        publicFunction(); // OK
        protectedFunction(); // OK, вызывается переопределенный метод
        privateFunction(); // Ошибка! Приватный метод остался приватным
    }
protected:
    virtual void protectedFunction() override;
};

int main2()
{
    auto d = new Derived3();
    d->publicFunction(); // Ошибка! Из-за приватного наследования публичные методы превратились в protected
    d->protectedFunction(); // Ошибка! Метод остался protected
    d->privateFunction(); // Ошибка! Метод остался приватным
}

// Защищённое наследование полезно для реализации "управляемого полиморфизма": в методах
// производного класса, а также в методах всех последующих классах-потомках класс
// Derived3 выступает теперь как базовый - сслыки и указатели на объекты класса Derived3
// можно использовать там, где ожидаются ссылки и указатели на объекты Base.



// 2. Виртуальное наследование
// ---------------------------

// Пусть у нас есть базовый класс base, который хранит целое число:
struct base { int x = 0; };
// Пусть мы объявляем два производных класса, которые по-разному работают с этим числом:
struct derived1 : base { /*members*/ };
struct derived2 : base { /*members*/ };
// Теперь, если нам нужно будет объединить их функционал в обном объекте, мы можем
// объявить производный класс, наследующийся от них обоих:
struct most_derived : derived1, derived2 { /*members*/ };

// Классы derived1 и derived2 оба хранят переменную x, и класс most_derived через наследование
// получил оба экземпляра этой переменной. Очевидно, целью было объединить функционал
// классов derived1 и derived2, но не данные, которые они хранят.

// Решением является виртуальное наследование:
struct derived1 : virtual base { /*members*/ };
struct derived2 : virtual base { /*members*/ };

// Без виртуального наследования производные классы просто вызывают конструкторы
// своих непосредственных предков.
// В случае виртуального наследования класс most_derived сам отвечает за вызов самого верхнего
// базового класса. Если вы этого не сделаете, компилятор автоматически вызовет
// конструктор по умолчанию для класса base:

derived1::derived1() : base(){}
derived2::derived2() : base(){}
most_derived::most_derived() : derived1(), derived2(), base(){}

// В настоящем примере мы должны явно вызвать конструкторы всех базовых классов, и для
// derived1, derived2, и для most_derived.


// 3. Абстрактные классы и интерфейсы
// ----------------------------------

// Часто при проектировании структуры программы возникает задача построить иерархию
// классов, которая позволяла бы легко добавлять новые сущности путем наследования от
// базового класса. Производные классы в этом случае получают все члены базового класса,
// переопределяя те члены, поведение которых требуется скорректировать.
// Но что если базовый класс не имеет собственного поведения? К примеру, если взять
// базовый класс Figure и производные классы Rectangle и Circle. Производные фигуры
// умеют отрисовывать себя, переопределив виртуальный метод draw() базового класса.
// Однако базовый класс не умеет отрисовывать себя, так как не является какой-то
// конкретной фигурой.

class Figure
{
public:
    virtual ~Figure() {}
    virtual void draw()
    {
        // метод ничего не делает, так как Figure не знает, как себя отрисовать
    }
};

class Rectangle : public Figure
{
public:
    virtual void draw() override
    {
        //Rectangle знает, как себя отрисовать
        //инструкции по отрисовке
    }
};

// Мы видим, что метод Figure::draw() пустой. Он и должен быть пустым. Но фактически он
// не нужен. Однако мы не можем оставить его без определения:
// строка virtual void draw(); без тела функции вызовет ошибку компиляции
// Существует механизм обозначить компилятору: компилировать тело метода не требуется.
// метод должен остаться чисто виртуальным:

class BetterFigure
{
public:
    virtual ~BetterFigure() {}
    virtual void draw() = 0; //метод остался без тела - чисто виртуальный метод
};

// При этом переопределение чисто виртуального метода работает как обычно:
class BetterRectangle : public BetterFigure
{
public:
    virtual void draw() override
    {
        //Rectangle знает, как себя отрисовать
        //инструкции по отрисовке
    }
};

// Теперь мы уже не сможем создать экземпляр класса BetterFigure:
// BetterFigure *fig = new BetterFigure; //не скомпилируется
// Но сможем создавать экземпляры производных классов и хранить в указателях на базовый класс:
// BetterFigure *fig = new BetterRectangle; // OK

// Класс BetterFigure называется абстрактным. Мы не можем создавать экземпляры этого класса
// и обязаны переопределить все его чисто виртуальные методы, если хотим использовать его функционал

/// Интерфейс

// Интерфейсом в C++ называется абстрактный класс, все методы которого являются
// чисто виртуальными. Практически всегда интерфейсы не хранят данные, а лишь предоставляют
// набор методов. Класс-интерфейс можно воспринимать как "контракт, описывающий нужный
// функционал": если какой-то класс унаследован от интерфейса, то он обязан переопределить
// все его методы.



// 4. Получение информации о классе на этапе выполнения программы
// --------------------------------------------------------------

// При использовании полиморфизма очень часто объекты производных классов хранятся в куче по
// указателям на базовый класс. Как узнать, какого именно типа объект был создан
// по этому указателю?

// В C++ существует специальный механизм, называемый Runtime Type Information (RTTI).
// Информацию о типе можно получить с помощью оператора typeid:

string str = "hello";
const type_info& ti = typeid(str);
std::cout << ti.name() << endl;

// class std::basic_string<char,struct std::char_traits<char>, class std::allocator<char> >

// Оператор typeid возвращает константную ссылку на объект типа type_info. Метод name()
// вернет строку с описанием типа. Иногда удобнее использовать не строку с описанием типа,
// а число, являющееся хеш-значением этой строки. Получить его можно методом hash_code().
// Хеш-код удобен, когда требуется хранить информацию о типах объектов в ассоциативных контейнерах.
// Для типа type_info переопределены операторы сравнения ==, !=, их можно использовать для
// сравнения типов объектов.
// Оператор typeid применим как к переменным, так и к классам (как и оператор sizeof)

struct base {};
struct derived : base { void f(); };
void call_me(base *bp)
{
    derived *dp = (typeid(*bp) == typeid(derived))
                  ? static_cast<derived*>(bp) : nullptr;
    if (dp != nullptr) dp->f();
}
int main()
{
    derived d;
    call_me(&d);
    return 0;
}
// В коде выше для приведения указателя на void к указателю на derived используется оператор
// static_cast. Он работает для любых типов данных, но следует помнить, что если типы данных
// не совместимы, оператор static_cast вернет испорченный объект.

// В отличие от static_cast, оператор dynamic_cast осуществляет проверку валидности
// преобразования типа во время выполнения программы (runtime check). Если объект можно
// преобразовать к требуемому типу, оператор вернет валидный указатель на этот тип.
// Если же преобразование невалидно, оператор dynamic_cast вернет нулевой указатель.
// Типичная область применения оператора dynamic_cast - преобразование указателя
// на базовый класс к указателю на производный класс.

// Функцию call_me выше можно переписать следующим образом:
void call_me2(base *bp)
{
    derived *dp = dynamic_cast<derived*>(bp);
    if (dp != nullptr) dp->f();
}
// Но для того, чтобы такой код работал, базовый класс должен быть полиморфным
// (необходимо сделать виртуальным один из его методов, обычно деструктор).


// 5. Удаление методов из класса
//------------------------------

// Если вы пишете код для других разработчиков, и не хотите, чтобы они вызывали
// определенные методы ваших классов, то самый простой способ - не объявлять эти методы.
// Нет метода - нет проблемы. Однако в некоторых случаях C++ сам объявляет методы
// за вас (это касается специальных методов - the big five: конструктор, деструктор,
// оператор копирования, копирующий конструктор, перемещающий конструктор).

// Чаще всего возникает задача заблокировать возможность копирования объекта, то есть
// не дать вызывать оператор копирования и копирующий конструктор.
// В C++ до версии C++11 существовал единственный способ решения этой задачи:
// объявить их приватными. Рассмотрим такой пример. В стандартной библиотеке C++
// за операции с потоками отвечают классы istream и ostream, которые унаследованы от
// базового класса basic_ios. Копирование объектов-наследников класса basic_ios
// нежелательно, так как не совсем понятно, как такое копирование должно осуществляться.
// Например, если мы работаем с объектом класса istream, и мы осуществили чтение порции данных
// из потока, должны ли мы при копировании потока также копировать и прочитанные данные?
// Если должны, то как их извлечь? Если не должны, то исходный поток и его копия
// больше не находятся в одинаковом состоянии.
// Поэтому копирование в классе basic_ios объявлено так:

class basic_ios : public ios_base {
public:
  //...
private:
  basic_ios(const basic_ios& );            // not defined
  basic_ios& operator=(const basic_ios&);  // not defined
};

// Объявление методов приватными блокирует возможность их вызова из сторонних классов.
// Если мы вообще не будем их объявлять, то компилятор объявит и скомпилирует их за нас
// (так как это специальные автогенериремые методы).

// В C++11 появилась новая возможность обозначить, что вызывать метод нежелательно.
// Мы можем просто удалить его из класса, добавив спецификатор = delete

class basic_ios : public ios_base {
public:
  //…
  basic_ios(const basic_ios& ) = delete;
  basic_ios& operator=(const basic_ios&) = delete;
  //…
};

// Разница между удаленным методом и приватным методом следующая: приватный метод, если
// он определен, можно вызывать в методах базового класса. Удаленный метод вызвать
// невозможно. Кроме того, объявить удаленной можно любую функцию, а приватным можно
// сделать только метод класса:

// Пример: в C++ многие примитивные типы данных неявно преобразуются к целочисленному типу.
// Если у нас есть функция, которая дожна принимать только аргумент типа int, то заблокировать
// неявное приведение можно, удалив соответствующие перегрузки:

bool isLucky(int number);
bool isLucky(char) = delete;
bool isLucky(bool) = delete;
bool isLucky(double) = delete;

// Обычно удаленные методы объявляют в публичной секции.


// 6. Запрет наследования и переопределения
//    -------------------------------------

//Существует возможность запретить наследование класса или переопределения виртуального
//метода с помощью зарезервированного слова final.
//Применительно к методу это слово означает, что дальнейшее переопределение виртуального
//метода запрещено, и компилятор будет выдавать ошибку в противном случае.
//Применительно к классу final означает запрет создавать производные классы.
struct Base
{
    virtual void foo();
};

struct Child : Base
{
    void foo() final; // Base::foo переопределена, Child::foo - конечная версия
    void bar() final; // Ошибка: bar не может быть финальным, так как он не виртуальный
};

struct Grandchild final : Child // struct Grandchild финальная
{
    void foo() override; // Ошибка: foo нельзя переопределить в Grandchild, так как
                         // он финальный в Child
};

struct GreatGrandchild : Grandchild // Ошибка: Grandchild финальный
{
};

#endif // OOP_ADDITIONAL_H
