#ifndef FUNCTIONS_H
#define FUNCTIONS_H

#include <iostream>
#include <vector>
#include <algorithm>

//Функция - это "кирпичик" программы, позволяющий избегать дублирования кода в программе.
//Если ваш код выполняется всего один раз, то его необязательно выносить в отдельную функцию.
//Если ваш код выполняется хотя бы два раза, то лучше его обособить от остальной программы.

//Обычно создание функции разбивают на две части: объявление и определение.
//Объявление функции выносят в заголовочный файл .h (причем обычно в этот заголовочный
//файл выносят все функции, объединенные одинаковым функционалом).

//файл .h
int getMaxOfTwoInts(int first, int second);

//Определение функции размещают в файле реализации .cpp
//файл .cpp
int getMaxOfTwoInts(int first, int second)
{
    //код функции
}

//Такое разделение упрощает компиляцию программы: если вы используете объявленную функцию
//в других файлах cpp, то вам достаточно включить ее заголовочный файл директивой #include.
//Компилятор при этом будет видеть, что функция объявлена, но не потребует определения
//функции, пока не начнет компилировать файл cpp, содержащий вызов этой функции.
//Если мы объединим объявление и определение функции в одном заголовочном файле, то при
//включении этого заголовочного файла в другой файл cpp компилятор будет добавлять в скомпилированный
//cpp весь код функции, так как он целиком находится в заголовочном файле. Это ведет к т.н.
//ошибкам линковки: функция оказывается определена в нескольких файлах cpp, и
//при линковке отдельных скомпилированных файлов cpp в единый исполняемый файл мы получаем
//несколько экземпляров функции в исполняемом файле, что не допускается стандартом C++.
//Если объявляемая функция нужна только в одном файле cpp, то можно разместить ее объявление
//и определение в этом файле, не вынося объявление функции в файл .h.
//Если мы разместим объявление и определение функции в один файл cpp, то мы не сможем
//использовать эту функцию в других файлах cpp, так как в C++ принято не включать файлы cpp директивой #include.


//Объявление функции - это ее сигнатура. В сигнатуру функции включаются:
//- тип возвращаемого значения, с дополнительными модификаторами
//- имя функции
//- список аргументов функции
//- дополнительные модификаторы сигнатуры функции.

//Функция может вернуть объект любого простого типа (int, double, char, bool)
//или объект любого класса. Функция может вернуть объект составного типа, например,
//указатель или ссылку на объект.
//Если функция ничего не возвращает, она должна быть объявлена с возвращаемым значением void.

//Функцию, возвращающую значение типа bool, часто называют _предикатом_:
struct CreditOffer
{
    //члены класса, описывающие кредит
    //...
};
//бинарный предикат, который можно использовать в программе
bool firstOfferBetter(const Offer &offer1, const Offer &offer2)
{
    bool better = false;
    // код, сравнивающий два кредита
    //...
    return better;
}


//Список аргументов может быть пуст, или включать от 1 до бесконечности аргументов.
//Помните, что чем больше у функции аргументов, тем сложнее пользоваться такой функцией.
//Обычно количество аргументов не превышает 4.

//В объявлении функции имена аргументов можно опустить, так как компилятору нужна только сигнатура,
//то есть то, что отличает эту функцию от любой другой объявленной.
//файл .h
void sumVector(std::vector<int>); //<- опустили название аргумента
//файл .cpp
void sumVector(std::vector<int> vec) //<- определение функции, название аргумента опустить нельзя
{
    //код для суммирования вектора
}

//Использование функции - вызов функции - заключается в передаче в функцию конкретных
//значений ее аргументов и, если требуется, присвоение какой-то переменной значения,
//возвращаемого функцией

//Пример:
//Заголовочный файл .h
void justPrintArguments(int arg1, int arg2);
int printArgumentsAndReturnSum(int arg1, int arg2);
//Файл реализации .cpp
void justPrintArguments(int arg1, int arg2)
{
    std::cout << arg1 << " " << arg2 << std::endl;
}
int printArgumentsAndReturnSum(int arg1, int arg2)
{
    std::cout << arg1 << " " << arg2 << std::endl;
    int sum = arg1 + arg2;
    return sum;
}
int main()
{
    int x=5;
    int y=6;
    justPrintArguments(x, y); //вызываем первую функцию
    int z = printArgumentsAndReturnSum(x, y); //вызываем вторую функцию и копируем возвращаемое
                                              //значение в переменную z
    std::cout << " " << z << std::endl;
}
//Вызов функции строго говоря - это выполнение оператора (), который называется оператор
//вызова функции. Если этому оператору передать идентификатор и список аргументов, то
//компилятор начинает искать функцию с такой сигнатурой, и если находит, выполняет ее.
//Оператор () можно перегружать (менять его поведение), о чем будет рассказано позже при
//изучении классов.

//Аргументы по умолчанию
//----------------------

//В объявлении функции аргументам можно дать значения по умолчанию. Правило следующее:
//все аргументы со значениями по умолчанию должны идти после обычных аргументов.
//   Заголовочный файл
void multiplyBy(std::vector<int> &vec, int n=2);
//В определении функции значение по умолчанию опускается:
//   Файл реализации
void multiplyBy(std::vector<int> &vec, int n)
{
    //По умолчанию умножаем все элементы на два, или на заданное число
    for (int &v: vec) v *= n;
}
void useMultiplyBy()
{
    std::vector<int> v = {1,2,3,4};
    multiplyBy(v); //v = {2,4,6,8}
    multiplyBy(v,3); //v = {6,12,18,24}
}

//Как вы заметили, имя аргумента необязательно должно совпадать с именем переменной,
//которую мы передаем в функцию. Главное - чтобы совпадали типы.


//В примерах ниже мы не будем разделять объявление и определение функции, но помните,
//что хорошей практикой является соблюдать такое разделение.


//Возвращение результата
//----------------------

//После выполнения тела функции, если эта функция должна вернуть значение, пользуйтесь
//оператором return

int getIdentity(int x)
{//Эта функция просто возвращает переданное ей число
    return x;
}

//Вы можете завершить выполнение функции оператором return в любой момент, если этого
//требует алгоритм:
int getMaxOfTwo(int first, int second)
{
    if (first>second) return first; //если 1-е > 2-го, возвращаем 1-е
    else return second; //иначе возвращаем 2-е
}

//В последнем примере хорошим тоном считается опускать слово else в таком случае,
//так как при выполнении инструкции return first; ветка else уже не выполнится никогда.
int getMaxOfTwo1(int first, int second)
{
    if (first>second) return first; //если 1-е > 2-го, сразу завершаем функцию, возвращая 1-е
    return second; //иначе возвращаем 2-е
}

//Функцию getMaxOfTwo можно переписать и неоптимальным, но более ясным кодом:
int getMaxOfTwoLong(int first, int second)
{
    int result; //объявим переменную, куда будем копировать большее число
    if (first>second)
        result = first;
    else
        result = second;
    return result; //возвращаем результат
}

int getMaxOfTwo2(int first, int second)
{
    return first>second ? first : second; //если 1-е > 2-го, сразу завершаем функцию, возвращая 1-е
}

//Такой вариант (с ветвлением) часто используется, так как многими руководствами
//по программированию рекомендуется писать функции, имеющие только одну точку завершения
//функции (только один оператор return), так как при этом облегчается изменение кода такой функции.

//Общее правило (упрощенное) здесь следующее: функция выполняется, пока в теле функции
//имеются выполнимые инструкции, или пока не встретится оператор return.

//Справа от оператора return может стоять не только имя переменной, но и сложное выражение.
//Компилятор это воспринимает как необходимость вычислить значение выражения и вернуть из
//функции:

//Задача о расчете стоимости ковровой дорожки
double getTotalPrice(double lengthInMetres, double pricePerMetre,
                     double discount, double lengthWithoutDiscount)
{
    return (lengthInMetres<=lengthWithoutDiscount ?
                lengthInMetres * pricePerMetre :
                pricePerMetre * (lengthWithoutDiscount + (lengthInMetres-lengthWithoutDiscount) * (1.0-discount)));
}

//Задания:
//1. Напишите функцию, которая складывает три вещественных числа и возвращает результат
//   аргументы функции - три вещественных числа
//   возвращаемое значение - вещественное число
//2. Напишите функцию, возвращающую среднее арифметическое двух вещественных чисел.
//3. Напишите функцию, принимающую целое число и возвращающую символ 'p', если число положительное,
//   символ 'n', если число отрицательное, и 'z', если число равно 0
//4. Напишите функцию, определяющую, является ли символ цифрой ('0'-'9').
//   (Такие функции называются предикатами. Они возвращают значение типа bool, вычисляемое
//   по своим аргументам)
//5. Напишите функцию, увеличивающую число x на определенное значение n, и возвращающую
//   результат. Если в функцию передается только один аргумент, то n должно быть равно 1.
//6. Напишите функцию, увеличивающую или уменьшающую число x на величину n. Увеличение
//   или уменьшение определяется третьим аргументом, по умолчанию он соответствует увеличению.

//Область видимости и локальные переменные
//========================================

//В языке C++ существует понятие области видимости. Это часть кода программы, в которой
//и только в которой можно использовать объявленную переменную, константу, функцию или класс.

//Глобальная область видимости (для файла) - объявленная переменная видна во всех функциях,
//определенных ниже этой переменной, в пределах одного файла cpp.

const double PI = 3.1415926; //<- это глобальная константа для текущего файла. Так как этот файл

//является заголовочным, то при включении этого заголовочного файла в другие файлы
//константа PI будет видна и в них. Таким способом можно расширять область видимости
//констант и переменных на другие файлы.
//Если мы объявим глобальную переменную в файле cpp, то только этот файл будет видеть
//переменную, так как в C++ не принято включать файлы cpp в другие файлы (хотя и допустимо)

//Локальная область видимости - более узкая, чем глобальная. В общем случае она ограничена
//фигурными скобками.

//Локальная область видимости функций
//-----------------------------------

//В локальную область видимости функции кроме идентификаторов, объявленных непосредственно в
//теле функции, добавляются еще и аргументы функции. Например, в функции multiplyBy локальными
//будут переменные vec и n, а в функции useMultiplyBy локальная переменная - это v.

//Локальная область видимости циклов и условий
//--------------------------------------------

//Аналогично функциям, в локальную область видимости циклов for, while, do while и условий if
//включаются переменные, объявленные в условиях циклов и условий (то есть в круглых скобках).

//Локальная область видимости блока кода
//--------------------------------------

//В локальную область видимости блока кода включаются идентификаторы, объявленные в этом блоке.

//Пример:
//сама сигнатура функции попадает в глобальную область видимости
int sumVector1(std::vector<int> vec) //аргумент vec попадает в локальную область видимости функции
{
    int sum = 0; //локальная для функции, видна везде ниже, но не вне функции
    for (unsigned int i=0; i<vec.size(); ++i) {//i локальная для цикла, не видна вне цикла
        int x = vec[i]; //локальная для цикла, не видна вне цикла
        sum += x; //можем использовать sum, так как она локальна для всей функции, в том числе внутри
                  //блоков, расположенных ниже точки объявления sum
    }
    x = 8; //ошибка! переменная x не определена
    i = 0; //ошибка! переменная i не определена
    return sum; //OK, sum объявлена в той же области видимости
}



//Call-by-value и call-by-reference
//=================================

//Если вы передаете в функцию какую-то переменную, то она становится локальной для
//этой функции, то есть она будет изменена только в самой функции, а значение исходной переменной не изменится:
void increase(int i)
{
    i = i+5;
}

void useIncrease()
{
    int a = 4;
    increase(a);
    std::cout << a; //выведет 4, так как переменная a, переданная в функцию increase,
    //становится в функции локальной, и ее изменение в функции никак не отразилось на значении
    //переменной а.
}

//Такой механизм называется call-by-value - передача аргументов в функцию по значению.
//Это значит, что в функцию передаются не сами переменные, определенные где-то выше,
//а только их копии, то есть совершенно новые переменные. Таким образом, int a, передаваемое
//в функцию increase, и int i, являющееся аргументом функции, хотя и имеют одинаковое
//значение, являются разными переменными.

//Запомните: если вы передаете переменные в функцию по значению, то при этом совершается
//копирование значений переменных в новые переменные, локальные для функции.

//Функцию increase можно переписать следующим образом, тогда она будет работать:
int betterIncrease(int i)
{
    i=i+5; //изменили значение локальной переменной
    return i; //вернули это значение из функции
}

void useIncrease1()
{
    int a = 42;
    a = betterIncrease(a);
    std::cout << a; //выведет 47
}

//Если же такое поведение вас не устраивает, и вы хотите при выполнении функции изменить
//значение передаваемой в нее переменной, то вы должны передать ее по ссылке:
void increase1(int & i) //<- теперь агрумент функции передается по ссылке
{
    i = i+1;
}

void useIncrease2()
{
    int a = 4;
    increase1(a); //Мы хотим увеличить a на единицу, воспользовавшись функцией.

    std::cout << a; //выведет 5, так как переменная a передана в функцию increase по ссылке.
}

//Агрументы, переданные в функцию по ссылке, не являются локальными для функции, то есть их изменение
//в теле функции отражается на исходной переменной. Фактически это одна и та же переменная,
//просто с разным именем. Такой механизм называется call-by-reference.

//(Более строго: локальной для функции является ссылка на переменную, объявленную выше, но так
//как ссылка позволяет обратиться к той же области памяти, в которой размещается переменная,
//это позволяет изменять значение переменной по ссылке).

//Запомните: если вы передаете переменные в функцию по ссылке, то при этом копирование значений
//переменных не совершается, а все изменения агрумента функции отразятся на передаваемой
//в функцию переменной.

//Конечно, если функция имеет несколько аргументов, то часть из них может передаваться по значению,
//а часть - по ссылке.

//Как выбрать - передавать аргументы по значению или по ссылке?
//1. Если передаваемый аргумент - это просто какая-то вспомогательная величина, которую достаточно
//будет прочитать один раз, то передавайте по значению.
//2. Если передаваемый аргумент - это объект, который вы хотите изменить в обособленном коде,
//то передавайте его по ссылке.

//Пример: Функция, удаляющая из вектора первые n элементов, будет принимать вектор по ссылке,
//        а число n - по значению, так как n - константа, не меняющаяся в теле функции,
//        а вектор - объект, который будет изменен в результате выполнения функции
void removeElements(std::vector<int> &v, int n)
{
    v.erase(v.begin(),v.begin()+n);
}
//Дополнение: конечно, такую функцию можно переписать таким образом, чтобы она возвращала
//новый вектор, а старый вектор не трогала:
std::vector<int> removeElements(const std::vector<int> &v, int n)
{
    std::vector<int> v1;
    std::copy(v.begin()+n,v.end(), std::back_inserter(v1));
    return v1;
}


//Перегрузка функций и неявное приведение типов
//---------------------------------------------

//Если вы написали функцию, которая принимает аргумент вещественного типа по значению,
//но передали в функцию целое число, то компилятор неявно преобразует это число к вещественному.
double doSmth(double x)
{
    return x*x;
}
void useDoSmth()
{
    int i=3;
    double result = doSmth(i); //result = 9.0
}
//И вообще - если компилятор может преобразовать один тип в другой без потери точности,
//то такое неявное приведение никак не будет сигнализироваться компилятором.
//Не всегда такое неявное приведение желательно. Например, мы хотим, чтобы наша функция
//работала по-разному в зависимости от того, аргумент какого типа мы передаем.
//Для решения этой проблемы можно объявить еще одну функцию с точно таким же именем,
//но с отличным списком аргументов.
//Пример: возведение вещественного числа в вещественную степень сложнее возведения в целую степень,
//поэтому мы можем использовать разные алгоритмы, и написать две функции с разными аргументами:
double makePow(double x, int n)
{

}
double makePow(double x, double n)
{

}
//При вызове этих функций с аргументами разных типов компилятор выберет наиболее подходящую:
void useMakePow()
{
    double x = 1.2;
    int n=4;
    double m=4.0;
    double result = makePow(x, n); //будет вызван первый вариант функции
    double r = makePow(x, m); //будет вызван второй вариант
}
//Механизм объявления функций с одинаковым именем называется перегрузкой функций.

//Правила перегрузки функций:
//1. Перегружаемые функции должны иметь одинаковое имя.
//2. Перегружаемые функции должны иметь разный тип аргументов или разное количество аргументов.
//2а.Перегружаемые функции могут иметь разный тип возвращаемого значения, но при этом должно
//   выполняться правило 2.
//3. Запрещается перегружать функции, отличающиеся только типом возвращаемого значения.
//4. Перегрузка функции с аргументами по умолчанию не должна совпадать ни с одним из вариантов
//   вызова такой функции.
//Пример на 4:
void badFunctionWithDefault(int x, int n=0)
{
    std::cout << "Исходная функция";
}
void badFunctionWithDefault(int x)
{
    std::cout << "Перегруженная функция";
}
void useBadFunction()
{
    //badFunctionWithDefault(3); Ошибка! Компилятор не знает, какую функцию мы вызываем.
    badFunctionWithDefault(3, 0); //OK
}

//Проектирование функций
//----------------------

//Вот основные вопросы, на которые следует ответить, прежде чем начать писать функцию:
//1. Насколько эта функция нужна? Будет ли она использоваться где-то еще в программе?
//2. Будет ли эта функция возвращать какое-либо значение? Или она просто будет выполнять какие-то
//   действия?
//3. Какое количество и тип аргументов оптимальны для удобного использования этой функции?
//4. Потребуется ли создавать несколько функций с разными типами аргументов? Или одной функции
//   будет достаточно?
//5. Вопросы 2-4 можно объединить одним: Что является входными данными для функции, и что
//   является выходными данными? От ответа на этот вопрос зависит и тип возвращаемого
//   значения, и типы и количество аргументов, и способ передачи аргументов в функцию.


//Задания:
//--------
//Во всех заданиях, где возможно, перегрузите функцию вариантом, принимающим аргумент по ссылке,
//и возвращающим void.
//Во всех заданиях 7-14 не требуется писать полную программу, тестирующую написанные функции.
//Достаточно только самой функции.

//7. Напишите функцию, проверяющую попадание точки (x, y) внутрь круга с радиусом R
//   и центром (a, b).
//8. Напишите функцию, возвращающую true, если три числа упорядочены по возрастанию.
//8а. Напишите функцию, упорядочивающую три числа по возрастанию. По убыванию (дополнительно).
//8b. Напишите функцию, упорядочивающую три числа по возрастанию или по убыванию в
//    зависимости от аргумента. cppreference
//9. Напишите функцию, возвращающую n-e число Фибоначчи.
//10. Напишите функцию, вычисляющую корни квадратного уравнения на множестве действительных чисел.
//   Функция должна возвращать фразу "No real roots", если корней нет,
//   фразу "One real root", если корень только один
//   фразу "Two distinct roots", если уравнение имеет 2 различных корня
//10a. Напишите функцию, вычисляющую корни квадратного уравнения на множестве комплексных чисел.
//11. Напишите функцию, определяющую количество цифр в целом положительном числе.
//12. Напишите функцию, обнуляющую значение переданной в нее переменной.
//13. Напишите функцию, увеличивающую стоимость товара добавлением налога (в %).
//14. Напишите функцию, меняющую местами значения двух переменных. Используйте передачу
//   аргументов по ссылке.

//Проекты
//-------

//15. Покупка пиццы.
//    Размеры пиццы обычно (в России) задаются диаметром в сантиметрах. Однако количество
//    пиццы определяется не диаметром, а площадью. Напишите программу, позволяющую
//    определить, какой заказ будет выгоднее: n пицц диаметром x сантиметров по цене p1
//    или m пицц диаметром y сантиметров по цене p2.
//    Расчет стоимости квадратного сантиметра пиццы оформите в виде отдельной функции.
//    Оценку выгоды реализуйте в виде функции-предиката, принимающей все необходимые
//    аргументы для вычисления результата.
//    Задание входных данных должно осуществляться в функции main чтением из консоли.
//    Выходные данные программы: фраза "первый вариант выгоднее" или "второй вариант выгоднее".
//    Пример: одна 50-см пицца за 400 руб или две 30-см за 250 руб.

//16. Игра "Быки и коровы".
//    Игра состоит в следующем: два игрока загадывают друг другу четырехзначные числа
//    с неповторяющимися цифрами от 1 до 9. Цель игры - первым угадать число противника.
//    Угадывающий называет четырехзначное число, а загадавший в ответ сообщает количество
//    цифр, совпавших по месту в названном числе и в загаданном (количество быков),
//    а также количество цифр, совпавших, но стоящих не на своем месте (количество коров).
//    Например:
//    загадано  спрашивается
//    1234      1567         - 1 бык
//    1234      1467         - 1 бык, 1 корова
//    1234      2341         - 4 коровы
//    Игроки ходят по очереди.
//    Напишите программу, реализующую игру "быки и коровы" против компьютера.
//    Компьютер генерирует случайное 4-значное число, а пользователь пытается отгадать
//    это число.
//    Реализуйте генерацию случайного числа в виде отдельной функции. Также вынесите
//    определение количества быков и коров в отдельную функцию.
//    Игра должна идти до выигрыша или до отказа игрока продолжать игру.
//    Совет: генерация произвольного случайного числа с неповторяющимися цифрами -
//    весьма сложная задача. Рекомендуется представить четырехзначное число в виде
//    четырех цифр. Тогда задача разбивается на четыре подзадачи:
//    - генерация первой цифры (генерируем случайное число в диапазоне [1-9])
//    - генерация второй цифры (генерируем случайное число в диапазоне [1-9]) до тех пор,
//      пока оно не станет отличаться от первой цифры
//    - генерация третьей цифры (генерируем случайное число в диапазоне [1-9]) до тех пор,
//      пока оно не станет отличаться от первых двух
//    - генерация четвертой цифры по тому же принципу.


#endif // FUNCTIONS_H
