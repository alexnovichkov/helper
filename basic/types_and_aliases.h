#ifndef TYPES_AND_ALIASES_H
#define TYPES_AND_ALIASES_H

#include <initializer_list>
#include <string>
#include <vector>
#include <memory>
#include <map>
#include <iostream>
#include <atomic>
#include <type_traits>

// Переменная в C++ - это имя (последовательность символов), с которым сопоставлено 
// некоторое значение определенного типа. Объявить переменную означает создать новое 
// имя и задать тип данных:
int integerVariable; // переменная integerVariable целочисленного типа
bool isJobDone; //переменная булевого типа
// После объявления переменной можно задать ей значение:
integerVariable = 67;
isJobDone = false;
// При этом заданное значение запишется в память компьютера.



//Основные типы данных в C++
//--------------------------

//Вначале несколько терминов.
//- Знаковый тип: переменная этого типа может дополнительно характеризоваться знаком
//  (то есть быть положительной или отрицательной)
//- Беззнаковый тип: переменная этого типа не характеризуется знаком, то есть биты его
//  значения интерпретируются только как неотрицательное число
//- Ширина типа: количество бит, отведенное под эту переменную. Стандарт языка не оговаривает
//  точную ширину стандартных типов, а лишь гарантирует, что под переменную будет отведено не меньше
//  определенного количества бит. Кроме того, на различных платформах ширина может
//  различаться

//Кратко что необходимо знать для начального уровня:
//- int для целых чисел.
//- unsigned int для целых неотрицательных чисел
//- double для вещественных чисел
//- char для символов английского алфавита, цифр и пунктуации
//- wchar_t для русских символов
//- bool для булевых значений true и false
//- void - для обозначения, что тип неважен или отсутствует

//1. Целочисленные типы
//---------------------
//Позволяют манипулировать целыми числами, со знаком или без знака, требуемой точности.
//Основное ключевое слово - int. Его можно дополнить словом unsigned, чтобы сделать тип
//беззнаковым. Слово short позволяет уменьшить ширину типа, слово long - увеличить.

//Кроме того, стандарт C++11 добавил новые имена типов с фиксированной шириной.

/*
--------------------------------------------------------------------------------
  имя                  ширина   знаковое минимальное значение максимальное значение
int                     >=32     да      -2^16 = -2147483648    2^16-1 = 2147483647
unsigned int            >=32     нет     0                      2^32-1 = 4294967295
short int               >=16     да      -2^8 = -32768          2^8-1 = 32767
unsigned short int      >=16     нет     0                      2^16-1 = 65535
long int                >=32     да      -2^16 = -2147483648    2^16-1 = 2147483647
unsigned long int       >=32     нет     0                      2^32-1 = 4294967295
long long int           >=64     да      -2^64/2 = -9223372036854775808     2^64/2-1 = 9223372036854775807
unsigned long long int  >=64     нет     0                      2^64-1 = 18446744073709551615

типы ниже определены в заголовочном файле <cstdint>
int8_t                    8      да      −128                   127
uint8_t                   8      нет     0                      255
int16_t                   16     да      −32768                 32767
uint16_t                  16     нет     0                      65535
int32_t                   32     да      −2147483648            2147483647
uint32_t                  32     нет     0                      4294967295
int64_t                   64     да      −9223372036854775808   9223372036854775807
uint64_t                  64     нет     0                      18446744073709551615
*/

//Замечание: Если в имени типа есть слова short, long или unsigned, то слово int можно опустить:
short m; //то же, что short int m;
unsigned mm; //то же, что unsigned int mm;

//Если вы попробуете присвоить значение 32768 переменной типа short int, то в переменную запишется
//другое число, так как 32768 не представимо 16 битами, то есть требуется переменная большей ширины.
//Но вы можете использовать слово auto для автовыведения типа переменной, тогда будет выбран тип
//переменной, достаточный для представления числа 32768.
//В стандарте C++ есть способы явно указать, типом данных какой ширины должен быть представлен 
//числовой литерал. Это возможно с помощью суффиксов, добавляемых к записи литерала.

//2. Вещественные типы
//Их всего три. В связи с особенностями представления вещественных чисел
//в бинарной форме эти типы не способны передать любое вещественное число - то есть,
//у этих типов есть конечная _точность_. В таблице ниже приведены минимальное представимое число
//и максимальное представимое число. Все вещественные типы являются знаковыми.

/*
имя          ширина  минимальное         максимальное
float        >=32    ±1.1754943·10^-38   ±3.4028234·10^38
double       >=64    ±2.2250738585072014·10^-308  ±1.7976931348623157·10^308
long double  >=80 или 64
*/

//Кодирование вещественных чисел в памяти компьютера описано в стандарте IEEE-754.

//Числовые литералы
//-----------------

//Записи ниже представляют целочисленные литералы

int d = 42;  //обычное число в десятичной системе
int nd = -42; //отрицательное число
int o = 052; //число в восьмеричной системе. Первый символ - всегда 0
int x = 0x2a; //число в 16-ричной системе, первые два символа - 0x или 0X
int X = 0X2A; //число в 16-ричной системе, первые два символа - 0x или 0X
int b = 0b101010; // число в двоичной системе, первые два символа - 0b
int bb = 0b1'011'101'000'111; //одинарные кавычки используются для разделения групп
                              //цифр

//Явное указание ширины типа литерала
//суффикс u или U используется для указания беззнаковости литерала
auto du = 42u; //du будет иметь тип unsigned int
//суффикс l или L используется для указания большей ширины
auto dl = 42l; //dl будет иметь тип long int
//суффикс ll или LL используется для указания двойной ширины
auto dll = 42ll; //dll будет иметь тип long long int
//суффиксы можно комбинировать:
auto dlu = 42lu; //unsigned long int
unsigned long long l3 = 1844'6744'0737'0955'0592uLL;

//Записи ниже представляют вещественные литералы

double d1 = 1.5; //литерал с дробной частью
double d2 = 1e-2; //литерал без дробной части, но с экспонентой, равен 1*10^-2 = 0.01
double d3 = 1.5e6; //литерал с дробной частью и экспонентой, равен 1.5*10^6 = 1500000.0
double d4 = 4.e3; //литерал без дробной части, но с сохранением разделителя, равен 4000.0
double d5 = .345; //литерал без целой части
double d6 = 23.45e-67; //литерал с целой, дробной частью и экспонентой

//Явное указание ширины литерала
//суффикс f используется для указания ширины float (32 бита)
auto f1 = 4.e3f; //float f1;
//суффикс l или L используется для указания ширины long double
auto d7 = 4.e3l; //long double d7;
//Отсутствие суффикса означает тип double;
auto d8 = 4.e3; //double d8;

//3. Символьные типы
//------------------
//Они построены вокруг типа char и используются для представления символов в памяти компьютера.
//Сам тип char 8-битный, причем его знаковость стандартом не оговаривается. Однако его можно
//сделать беззнаковым с помощью модификатора unsigned. На некоторых платформах char может
//иметь и большую ширину.

//Будучи 8-битным, тип char способен представить максимум 2^8 = 256 символов. Этого недостаточно
//для передачи символов любых национальных алфавитов. Поэтому стандартом C++11 были добавлены
//дополнительные символьные типы, способные хранить символы Unicode

//Так как тип char имеет ширину 8 бит, то есть 1 байт, то char часто используется как
//тип для выражения т.н. сырых двоичных данных (которые естественным для любого компьютера
//образом делятся на отдельные байты), то есть для хранения неструктурированной,
//нетекстовой информации.

/*
имя            ширина    количество символов       если представляет число
char            8           256                         -128..127
unsigned char   8           256                         0..255
wchar_t         16          65536
char8_t         8           256
char16_t        16          65536
char32_t        32          4294967296
*/

//Тип char используется для представления символов латинского алфавита, цифр, пунктуации,
//некоторых дополнительных символов, а также символов из т.н. национальных кодировок,
//количеством не более 128. Если файл сохранен в любой 8-битной кодировке (Windows-1251,
//KOI8-R, CP866, ISO 8859-1 и т.п.), то типа char достаточно, чтобы правильно прочитать все
//символы такого файла.

//Тип wchar_t, имеющий вдвое большую ширину, подходит для хранения в памяти гораздо
//большего количества символов. Он используется при обработке текстов на нескольких языках
//и является де факто стандартом в ядре Windows.

//Остальные типы были введены по той причине, что стандарт С++ не оговаривает точную ширину
//типов char и wchar_t.

//Необходимо понимать, что любая переменная в языке C++ в основе своей - просто
//последовательность единиц и нулей, то есть переменную любого типа можно интерпретировать
//просто как целое число в двоичной форме. Этот факт используется для, например,
//кодирования символьных литералов. Все символы, которые требуется закодировать,
//упорядочиваются в т.н. кодовой таблице, а затем им присваивается номер от 0 до
//2^n-1, где n - ширина типа. Полученное число - это числовое представление символа
//в памяти компьютера. Таким образом, кодирование символов в общем случае зависит
//от выбранной кодовой таблицы.

//В настоящее время всеобщее распространение получил стандарт кодирования символов Unicode.
//Этот стандарт каждому символу присваивает свой уникальный номер, от 0 до бесконечности,
//по которому символ однозначно идентифицируется (написание многих символов может меняться
//в зависимости от шрифта). Использование Unicode облегчает разработку кодовых таблиц.

//Раньше (в 80е годы) не существовало кодовых таблиц, кодирующих больше 256 символов.
//Поэтому каждый национальный алфавит имел свою кодовую таблицу. Текст, сохраненный в
//такой кодировке, не мог содержать, например, символы кириллицы и иероглифы одновременно.
//Стандарт Unicode добавил определение кодировок, позволяющих представить значительно
//большее количество символов.

//Наиболее распространенные кодовые таблицы:
//- ASCII - кодирует 128 символов: цифры, символы пунктуации, символы латинского алфавита, некоторые
//  дополнительные символы.
//- Windows-1251 - кодирует 256 символов, в первой половине (0-127 символы) совпадает
//  с ASCII, вторая половина (128-255 символы) отведена под символы кириллицы и некоторые другие символы
//- Windows-1252, 1253 и т.д. - кодовые таблицы европейских языков на основе латиницы
//- UTF-16 - кодирует 65536 символов, включает все символы европейских алфавитов,
//  арабский алфавит, китайские иероглифы, математические символы, расширенную пунктуацию
//  и т.д.
//- UTF-32 - кодирует 2^32 символов, теоретически включает все возможные символы, придуманные
//  человечеством. Не весь диапазон заполнен на данный момент.
//- UTF-8 - строго говоря, не кодовая таблица, а способ записи символов с номерами >=256 с помощью
//  8-битных чисел благодаря использованию разного количества байт под разные символы.


//Все печатаемые символы начинаются в большинстве кодовых таблиц с номера 32.
//Номер конкретного символа можно найти, если запустить, например, таблицу символов Windows.

//Номера с 0 по 31 отведены под т.н. управляющие символы. Это символы, которые не
//выводятся на печать (экран), но управляют выводом других символов или используются иначе.
//Наиболее часто используются:
//- символ с номером 0, использующийся как обозначение пустого символа
//- символ с номером 8, использующийся как обозначение стирания предыдущего символа (клавиша Backspace)
//- символ с номером 9, использующийся как обозначение табуляции (клавиша Tab)
//- символ с номером 10, использующийся как обозначение перевода строки (клавиша Enter)
//- символ с номером 12, использующийся как обозначение возврата каретки (клавиша Return)
//- символ с номером 4, использующийся как обозначение конца сообщения. На клавиатуре его можно набрать
//  комбинацией Ctrl+D


//Представление символов в исходных файлах C++
//--------------------------------------------

//Символы с номерами 32-127 представляются как есть: 'd', '7', '(', ' ', '*' и т.д.
//Символы с номерами 0-31 представляются своим кодом (см. ниже)
//Символы с номерами >=128 представляются в зависимости от кодировки, в которой сохранен файл cpp.
//- Если это однобайтная кодировка (Windows-1251), то в явном виде можно записывать только
//  те символы, которые поддерживаются этой кодировкой.
//- Если это кодировка UTF-8, то к литералу необходимо добавить префикс u8 (см. ниже):  u8'ф'
//- Если это двухбайтная кодировка UTF-16, то к литералу добавляется префикс u или L

//Если известен код символа, его можно записать в виде символьного литерала с помощью
//следующего синтаксиса:

char c1 = '\333'; //символ с номером 219 в восьмеричной системе счисления (три цифры 0-7)
char c2 = '\0';   //символ с номером 0 
char c3 = '\x0A';   //символ с номером 10 в 16-ричной системе счисления (две цифры 0-F)
char c4 = '\xFF';   //символ с номером 255 в 16-ричной системе счисления
wchar_t c5 = L'\uFEFF'; //символ с номером 65279 в 16-ричной системе счисления (четыре цифры 0-F)

//Последний символ уже не помещается в переменную типа char, поэтому у нее другой тип.

//Существуют также более краткие записи управляющих символов:

// \n - перевод строки
// \t - табуляция
// \r  - возврат каретки

//Кроме того, так как одинарные кавычки используются для записи символьных литералов,
//если требуется передать сам символ кавычки, используют последовательность '\''
//Символ \ можно записать как '\\'.

//Существует возможность указать тип символьного литерала с помощью префиксов:
//- отсутствие префикса означает тип char
auto c1 = 's';
auto wc_ = 'ы'; //Внимание! Будет работать, только если файл сохранен в кодировке Windows-1251
//- префикс L означает литерал типа wchar_t
auto wc = L'ы'; //Внимание! Будет работать, только если файл сохранен в кодировке UTF-8
auto wc1 = L'\x044b'; //работает всегда, означает символ 'ы'
//- префикс u8 означает литерал типа char8_t
auto wc2 = u8'a'; //Будет работать, если файл сохранен в любой однобайтной кодировке
//- префикс u означает литерал типа char16_t, то есть символ с номером <=65535
auto wc3 = u'猫'; //OK
auto wc4 = u'🍌'; //Ошибка! Банан имеет код 0001f34c > FFFF
//- префикс U означает литерал типа char32_t, то есть символ с номером <=2^32
auto wc3 = U'猫'; //OK
auto wc4 = U'🍌'; //OK

//Если кодировка файла исходных текстов (cpp или h) не позволяет непосредственно
//записать символы не из кодировки ASCII, то вы всегда можете использовать номер символа,
//с добавлением префикса если нужно.


//4. Булев тип
//------------

//Он только один - bool. Тип содержит только два литерала, true и false.

//5. Тип void
//-----------

//Он используется, если нужно указать, что функция не возвращает никакого значения
//или что точный тип переменной не определен/не важен. Присвоить этот тип переменной нельзя.
//Его можно воспринимать просто как зарезервированное слово.

//6. Составные типы.
//-----------------

//Это типы данных, полученные из перечисленных выше. Их мы будем изучать на следующих занятиях.


//Оператор sizeof
//---------------

//Этот оператор применяется, когда необходимо узнать ширину типа данных или ширину переменной.
//Он возвращает число типа std::size_t, которое на 32-битной платформе совпадает с
//unsigned int32_t, а на 64-битной платформе - c unsigned int64_t.

//Оператор sizeof может применятся как к переменным:
int x = 20;
std::cout << sizeof(x);
//так и к именам типов:
std::cout << sizeof(int);

//Обычно оператор sizeof применяется для чтения/записи двоичных файлов, для выделения памяти,
//достаточной для размещения n объектов определенного типа, для определения количества элементов в
//массиве.
int a[10];
std::cout << sizeof(a) / sizeof(int); //10

//Оператор можно использовать и как унарный оператор, то есть без скобок:
std::cout << (sizeof a) / (sizeof int);




//Задания
//-------

//1. Напишите, какой тип данных достаточен для представления следующих чисел:
// 1
// 1.1
// -1
// -1.456e23
// 40000
// 81230
// -81230
// 0.003
// -1.4e-567

//2. Объявите переменные всех перечисленных выше типов и выведите в консоль их ширину
//   Например: int x; std::cout << "int " << sizeof(x);

//3. С помощью таблицы символов Windows определите, что записано в следующей строке
//   литералов
//  \U0418\U0437\U0443\U0447\U0430\U0442\U044C\U0020\U0043\U002B\U002B\U0020\U043B\U0435
//  \U0433\U043A\U043E\U0020\U0438\U0020\U0447\U043F\U0440\U0438\U044F\U0442\U043D\U043E

//4. Изучите страницу Википедии https://ru.wikipedia.org/wiki/ASCII

//5. Изучите страницу Википедии https://ru.wikipedia.org/wiki/%D0%AE%D0%BD%D0%B8%D0%BA%D0%BE%D0%B4





//Дополнительный материал

//Синонимы типов - typedef и using
//--------------------------------

//Вместо имени типа можно создать и использовать его синоним, объявив его с помощью 
//зарезервированного слова using. Это слово было добавлено в версии C++11.
//Обычно синонимы используют, если исходное имя типа слишком длинное или не отражает семантики типа.


using byte     = unsigned char; //byte - синоним для unsigned char
using byte_ptr = unsigned char *; // синоним для указателя на byte
using array_t  = int[10]; //теперь вместо имени типа int[10] можно писать array_t
using fn       = void(byte, double); //синоним для сигнатуры функции

//Использование синонимов полностью аналогично использованию исходных имен типов

byte b{42}; //b имеет тип byte, совпадающий с unsigned char
byte_ptr pb = new byte[10] {0}; 
array_t a{0,1,2,3,4,5,6,7,8,9}; //то же, что int a[10] {0,1,2,3,4,5,6,7,8,9};

void func(byte b, double d) { /*...*/ } //если у нас где-то объявлена такая функция
fn* f = func; //используем синоним fn для объявления указателя на эту функцию

// - Дополнительно: -
//Синоним шаблона создается с помощью записи
//template<typename T,...> using identifier;
template <class T>
class custom_allocator { /* ... */ };
template <typename T>
using vec_t = std::vector<T, custom_allocator<T>>;
vec_t<int>           vi;
vec_t<std::string>   vs;

//
//Вы также можете по традиции использовать typedef, который использовался до C++11

typedef unsigned char   byte;
typedef unsigned char * byte_ptr;
typedef int             array_t[10]; //менее понятно, чем с using
typedef void(*fnn)(byte, double); //менее понятно, чем с using
template<typename T>
class foo {
  typedef T value_type;
};
typedef std::vector<int> vint_t;


#endif // TYPES_AND_ALIASES_H
