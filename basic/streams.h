// Этот файл описывает работу с потоками

/*
Большинство программ подразумевают некое взаимодействие с пользователем, обычно 
называемое пользовательским интерфейсом. Самый простой вид такого взаимодействия -
через консоль. 

При написании программ всегда думайте, как пользователь может (осознанно или нет)
использовать её интерфейс неправильно. Научитесь предвидеть ошибки пользователя
и предотвращать их появление. 
*/

/// Использование std::cin для получения данных от пользователя.


// Когда вы пишете нечто вроде
std::cin >> x;
//вы тем самым "извлекаете" данные, введенные пользователем, из потока ввода.
//Данные из потока не сразу попадают в переменные, вначале они накапливаются в 
//буфере потока, то есть в области памяти, связанной с std::cin.
//В буфер помещаются символы, введенные пользователем в консоли, в том порядке, в
//котором они были введены. При выполнении оператора чтения из потока >> эти 
//символы в том же порядке извлекаются из буфера, интерпретируются оператором >>
//и копируются в переменные.

//Если в буфере недостаточно данных для заполнения переменных, поток std::cin
//ждет нового ввода от пользователя. Если в буфере после заполнения переменных
//еще остались данные, они остаются в буфере до следующего раза.

//Примеры:

//1. Выполняется такой код:
int x;
std::cin >> x;
//Пользователь ввел два символа 5a и нажал Enter, закончив ввод. В поток ввода
//попали символы 5a\n - да, перевод строки тоже попадает в буфер.
//5 будет извлечена из потока и записана в переменную x. После этого в буфере 
//останутся два символа для последующего извлечения.

//Об этом всегда нужно помнить: переводы строки, которыми вы завершаете ввод, 
//тоже попадают в поток ввода и их тоже нужно обрабатывать.

//2. Несовпадение типов.

//Выполняется такой код:
int x;
std::cin >> x;
//Если пользователь введет "b\n", то чтение из потока закончится с ошибкой, так 
//как символ b нельзя конвертировать в целое число.

/// Как проверять вводимые данные

//Существует три метода проверки вводимых данных.

//1. Не дать пользователю совершить ошибку, используя особые возможности программы.
//Этот метод распространен в программах с графическим интерфейсом.

//2. Позволить пользователю вводить что угодно, записывать это в строку, а затем
//обрабатывать содержимое этой строки.
//Этот метод позволяет всегда гарантировать, что ввод пользователя не завершит 
//программу аварийно (не введет поток std::cin в состояние ошибки).

//3. Позволить пользователю вводить что угодно, но сразу обрабатывать ошибки 
//std::cin. Далее разговор будет идти именно о третьем методе.

/// Типы неправильного ввода пользователем

//1. Считывание из буфера успешно, но считанная величина бессмысленна
std::cout << "Enter the integer number in the range [0..10]";
int y; std::cin >> y;
//пользователь вводит -3

//Как исправить: заставить пользователя ввести то, что надо, с помощью цикла
int y; 
while (true) {
    std::cout << "Enter the integer number in the range [0..10]";
    std::cin >> y;
    if (y < 0 || y > 10)
        std::cout << "The number you input is invalid. Try again";
}

//2. Считывание из буфера успешно, но пользователь ввел лишнее.
std::cout << "Enter the integer number in the range [0..10]";
int y; std::cin >> y;
//пользователь вводит 3u. после считывания y в буфере остаются символы u\n. Если
//следующий шаг - считать число, чтение произойдет с ошибкой.

//Как исправить: игнорировать то, что не требуется, с помощью ignore:
int y; 
while (true) {
    std::cout << "Enter the integer number in the range [0..10]";
    std::cin >> y;
    if (y < 0 || y > 10)
        std::cout << "The number you input is invalid. Try again";
    std::cin.ignore(100, '\n');
}
//Последняя строка считывает из буфера не более 100 символов (или пока не 
//встретится перенос строки) и отбрасывает их, не помещая ни в какие переменные.
//Если неизвестно, сколько символов может ввести пользователь, то можно использовать
//такую длинную конструкцию:
std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
//вместе с предварительно подключенным заголовочным файлом <limits>

//3. Считывание из буфера прошло с ошибкой.
std::cout << "Enter the integer number in the range [0..10]";
int y; std::cin >> y;
//пользователь вводит 'u'

//Как исправить:
//Когда оператор >> не может преобразовать данные из буфера, он переходит в состояние
//ошибки. В этом состоянии все последующие попытки прочитать данные будут выдавать
//ошибку. В этом случае сначала нужно очистить состояние ошибки:
if (std::cin.fail()) {//проверяем наличие ошибки
    std::cin.clear(); //переводим поток в нормальное состояние
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');//удаляем ошибочные данные
}

//Так может выглядеть функция, которая запрашивает вещественное число от 
//пользователя и обрабатывает все три типа ошибок:
double getDouble()
{
    while (true) 
    {
        std::cout << "Enter a decimal number: ";
        double x = 0;
        std::cin >> x;

        if (std::cin.fail()) 
        {
            std::cin.clear(); 
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        }
        else 
        {
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            return x; 
        }
    }
}

