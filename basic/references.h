#ifndef REFERENCES_H
#define REFERENCES_H

#include <iostream>
#include <vector>

using namespace std;

void references()
{
    //Ссылка на переменную - это фактически второе имя переменной:
    int x = 4; //переменная x
    int &y = x; //та же переменная x, но с другим именем

    x=6; //y тоже стала равна 6
    y=7; //x тоже стала равна 7

    //Физически ссылка на переменную - это просто другой идентификатор области памяти.
    //Поэтому невозможно создать неинициализированную ссылку или ссылку на литерал:
    double &z; //Ошибка! Неинициализированная ссылка
    double &f = 3.14; //Ошибка! Попытка получить ссылку на числовой литерал

    //Можно объявлять константные ссылки, которые позволяют обращаться к переменной
    //как к константе по одному имени, но как к переменной по другому:
    const int &xx=x;
    xx=8; //Ошибка! Константе нельзя присвоить значение
    x=8; //OK

    //Для чего используются ссылки:
    //--------------------------------------

    //1. Для прямого доступа к элементам контейнеров
    vector<double> vec;
    double &tempVar = vec[2]; //оператор [] возвращает ссылку на элемент вектора с индексом 2
    //дальше работаем с tempVar, изменения в ней отражаются в векторе.
    tempVar = 3; //vec[2] тоже стал равным 3

    //Просто написать double tempVar = vec[2] не достаточно, так как при этом просто
    //будет скопировано значение из vec[2] в tempVar, и при изменении значения tempVar
    //значение элемента вектора vec[2] меняться не будет.

    //2. Для прямого доступа к членам класса
    class Fred
    {
    public:
        std::string &name() {return _name;}
    private:
        std::string _name;
    };
    Fred f;
    f.name() = "Joe";

    //Такая техника позволяет создавать т.н. цепочки вызовов (method chaining). 
    //Цепочки вызовов используются для последовательного изменения состояния объекта
    //в определенном порядке:
    class Joe
    {
    public:
        Joe &setName(std::string name);
        Joe &setAge(int age);
        Joe &setAddress(const Address &address);
    private:
        std::string _name;
    }
    Joe joe;
    joe.setName("Fred").setAge(15).setAddress({2315, "Main st.", "Tulsa"});
    //Методы, используемые таким образом, должны возвращать ссылку на собственный объект.
    //Воо так, например, может быть реализован метод setName()
    Joe &Joe::setName(std::string name) 
    {
        _name = name;
        return *this; //разыменовывает указатель на текущий объект и возвращает ссылку
    }

    //3. Чтобы избежать лишнего копирования возвращаемых значений

    int findMax(vector<int> &vec) {
        int max = vec[0];
        ...
        return max;
    } //<- из функции возвращается копия максимального элемента

    int &findMax(vector<int> &vec) {
        int &max = vec[0];
        ...
        return max;
    } //<- из функции возвращается ссылка на максимальный элемент

    vec[i] = 15;

    auto &maxElem = findMax(vec);
    maxElem=15; //vec[i] == 15
    vec.remove_all(maxElem);

    //4. Чтобы изменения значений аргументов функции были видны снаружи функции.
    void swap(T & a, T & b); // изменения a и b внутри функции приведут к изменению исходных переменных

    //5. Чтобы избежать лишнего копирования агрументов функции
    void iterateOver(std::vector<int> vec); //- при передаче вектора в функцию функция получает копию
                                            //исходного вектора
    void iterateOver(const std::vector<int> &vec); //- при передаче вектора в функцию функция
                                                   //получает исходный вектор как константу под
                                                   //другим именем


    //При использовании ссылок необходимо помнить следующие вещи:
    //1. Ссылка всегда должна быть инициализирована при объявлении.
    int &yy; //Запрещено
    //2. Ссылка не может быть инициализирована литералом или анонимным результатом выражения.
    int &y1=4; //Запрещено
    int &y2=x+y; //Запрещено
    swap(1,3);  //Запрещено
}

#endif // REFERENCES_H
