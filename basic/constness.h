#ifndef CONSTNESS_H
#define CONSTNESS_H

#include <map>
#include <iostream>
#include <vector>

///
/// В этом файле рассматриваются слова const и constexpr
///

// В программировании константа - это переменная, которую нельзя изменить после
// присвоения начального значения.

void using_const()
{
    //Зарезервированное слово const используется для объявления константных объектов:
    const double pi=3.1415926; //объявление константы pi
    //В отличие от переменных, константные объекты после объявления невозможно модифицировать:
    pi=4; //Ошибка!

    //Корме того, константа всегда должна быть инициализирована:
    const double wrong; // ! ошибка!
    const double right {23.45}; // правильно!

    //Следует аккуратно использовать const с составными типами:
    int speed1 = getSpeedOfCar(car1);
    int speed2 = getSpeedOfCar(car2);
    //указатель на константу.
    const int * speedRef = &speed1;
    //Его можно переназначить на новый адрес:
    speedRef = &speed2;
    //Но нельзя изменить значение, хранящееся по адресу speedRef:
    *speedRef = 5; //Ошибка!

    //Если же мы объявляем константный указатель, то ситуация иная:
    int * const speedRef1 = &speed1; //константный указатель.
    //Его нельзя переназначить на новый адрес:
    speedRef1 = &speed2; //Ошибка!
    //но можно поменять значение по адресу speedRef1:
    *speedRef1 = 5; //OK

    //Как определить, когда следует использовать const? Короткий ответ: пишите всегда,
    //если переменную не нужно будет менять, даже если это не явная константа.
}

//const используют в следующих случаях:
//1. При объявлении константных объектов, которые далее в коде не должны меняться

int countOfLoadedChannels() {
    //(подсчет количества загруженных в память каналов файла)
    int loadedCount = 0;
    const int totalCount = channelsCount(); //общее количество каналов, не меняется в функции,
                                            //поэтому объявлено константой
    for (int i=0; i<totalCount; ++i) {
        if (channel(i)->loaded()) loadedCount++;
    }
    return loadedCount;
}

//2. В объявлении аргументов функций с той же целью

//Обычно константными объявляются только аргументы, передаваемые по ссылке.

using container = std::map<std::string, std::string>;
//оба аргумента не изменяются в функции, поэтому объявлены константными
container filter(const std::string &filter, const container& data)
{
    if (filter.empty()) return data;

    container result;
    for (const auto [key, val] : data) {
        if (key.substr(0,filter.size()+1)==filter+".")
           result.insert(key, val);
    }

    return result;
}

//Объявление аргументов фукнции константными распространяет константность и на вызываемые
//в ней функции:
void g1(std::string& s); //аргумент - неконстантная ссылка
void f1(const std::string& s) //аргумент - константная ссылка
{
    g1(s);          // Ошибка компиляции! Нельзя передавать константу в функцию, 
                    // принимающую неконстантный аргумент
    std::string localCopy = s; //Лучше сделать локальную копию 
    g1(localCopy);  // OK, локальная копия не константна.
}

//3. При объявлении членов классов, которые не будут менять состояние объекта класса
//Иногда используют следующую терминологию: мутаторы - это методы, изменяющие состояние объекта,
//инспекторы - методы, не меняющие состояние объекта. Всегда делайте методы-инспекторы константными:
class Fred {
public:
  void inspect() const;   // инспектор, не меняет состояние объекта
  void mutate();          // мутатор, может (но не обязан) менять состояние объекта
};
void userCode(Fred& changeable, const Fred& unchangeable)
{
  changeable.inspect();   // ОК: не меняет изменяемый объект
  changeable.mutate();    // ОК: меняет изменяемый объект
  unchangeable.inspect(); // ОК: не меняет неизменяемый объект
  unchangeable.mutate();  // Ошибка: попытка изменить неизменяемый объект
}
//Все методы-геттеры по определению должны быть константными, все методы-сеттеры - неконстантными.
//Кроме того, если метод-инспектор возвращает объект, то он должен возвращать его по 
//константной ссылке или по значению, чтобы сохранить константность:
class Person {
public:
  const std::string& name_good() const;  // Правильный метод-инспектор
  std::string& name_evil() const;        // Ошибка: позволяет менять имя в нарушение константности
  int age() const;                       // Правильный метод - позволяет менять только копию возраста
};
void myCode(const Person& p)  // myCode() обещает не менять объект Person
{
  p.name_evil() = "Igor";     // Но myCode() меняет его здесь!!
}

//Существует такая вещь как const-перегрузка функций. Как вы знаете, C++ запрещает перегружать функции,
//отличающиеся только типом возвращаемого значения. У этого правила есть исключение:
//константный метод, возвращающий константную ссылку:
class MyFredList {
public:
  const Fred& operator[] (unsigned index) const;  
        Fred& operator[] (unsigned index);        
};
//Класс MyFredList объявляет два метода, отличающиеся константностью и константностью
//возвращаемого значения. Оператод [] часто перегружается таким образом, чтобы дать
//программисту возможность безопасно обращаться к элементам контейнера.

//4. При итерации по неизменяемым контейнерам
bool tracking(const std::string &file)
{
    const auto files = getFiles(); //получаем список файлов. Он не меняется, поэтому константный

    for (const auto &item: files) {//проверяем каждый файл
        //item не меняется в цикле, поэтому константный
        if (fileIsOK(file, item)) return true; //нашли файл
    }

    return false; //не нашли
}

//------------------------------------------------------------------------------
// Constexpr
//------------------------------------------------------------------------------

//Зарезервированное слово constexpr используется для указания компилятору, что значение
//переменной или значение вызываемой функции известно (или может быть известно) на
//этапе компиляции программы. Добавление этого слова к объявлению переменной или функции
//позволяет при компиляции программы заранее вычислить значение и подставлять в код
//сразу готовое значение.

//1. Constexpr объекты

//Значение таких объектов должно быть известно на этапе компиляции:
int size;
std::cin >> size;
constexpr int arraySize1 = size; // Ошибка! Попытка записать в constexpr-объект значение,
                                 // не известное на этапе компиляции
constexpr int arraySize2 = 10;   // OK, записываем литерал
std::array<int,arraySize2> a1;   // OK, теперь arraySize2 можно использовать как обычный литерал
const int arraySize3 = size;
std::array<int,arraySize3> a2;   // Ошибка! Обычные константы нельзя использовать там,
                                 // где требуется выражение, вычислимое на этапе компиляции

//Переменные с квалификатором constexpr можно использовать как обычные константы.
//Но наиболее полезны они:
//1. Для задания размера массивов
int array[arraySize2]; // Абсолютно легально
//2. Для задания значений в аргументах шаблонов
std::array<int,arraySize2> a3;
//3. как значения в перечислениях
//4. как спецификаторы выравнивания

//Следует четко отличать constexpr-объекты от const-объектов. Слово constexpr означает,
//что значение объекта должно быть известно на этапе компиляции. Слово const означает,
//что объект нельзя менять. Все constexpr-объекты являются одновременно и const-объектами,
//обратное же неверно.

//2. Constexpr функции

//Для функций слово constexpr означает просьбу компилятору в тех случаях, где это
//возможно, вычислить значение такой функции непосредственно при компиляции. При этом:
//- если значения аргументов функции известны на этапе компиляции, результат будет
//  также вычислен на этапе компиляции.
//- если это невозможно, функция будет вызываться как обычно.

//Отсюда следует важный вывод: constexpr-функции можно использовать в тех местах,
//где ожидается constexpr-объект или литерал. Пример:
constexpr int getArraySize(int rows, int cols) noexcept //помечаем функцию noexcept
                                                        //как никогда не кидающую исключений
{
    return rows*cols;
}
std::array<double, getArraySize(3,4)> matrix;

//Функцию getArraySize можно использовать и в обычных контекстах:

int rows, cols;
std::cin >> rows >> cols;
int vectorSize = getArraySize(rows, cols);
std::vector<int> v(vectorSize);

//Слово constexpr было добавлено в стандарт C++11. Согласно этому стандарту
//constexpr-функции могли включать только одну инструкцию со словом return (как getArraySize).
//В стандарте C++14 это требование было снято:

constexpr int pow(int base, int exp) noexcept       // C++14
{
    auto result = 1;
    for (int i = 0; i < exp; ++i) result *= base;
    return result;
}

//Constexpr-функции могут принимать аргументы и возвращать значение только литеральных
//типов (то есть простых типов вроде int, char, bool). Это ограничивает их полезность
//в случае использования с пользовательскими классами. Однако если учесть, что словом
//constexpr можно помечать методы класса, включая специальные методы, то можно обойти
//ограничения например таким способом:

class Point { // начиная с C++14
public:
    constexpr Point(double xVal = 0, double yVal = 0) noexcept
        : x(xVal), y(yVal)
    {}
    constexpr double xValue() const noexcept { return x; }
    constexpr double yValue() const noexcept { return y; }
    constexpr void setX(double newX) noexcept { x = newX; }
    constexpr void setY(double newY) noexcept { y = newY; }
private:
    double x, y;
};

//Конструктор класса Point объявлен как constexpr. Это значит, что если аргументы
//конструктора являются constexpr, то объекты этого класса сами являются constexpr,
//и класс можно использовать например так:
constexpr Point p1(9.4, 27.7);
constexpr Point p2(0.5, -1227.9);
//Более того, класс можно использовать как аргумент constexpr-функций:
constexpr Point midpoint(const Point& p1, const Point& p2) noexcept
{
    return { (p1.xValue() + p2.xValue()) / 2,
                (p1.yValue() + p2.yValue()) / 2 };
}
constexpr auto mid = midpoint(p1, p2);
//И значение переменной mid будет вычислено при компиляции и записано непосредственно
//в код исполняемого файла.

#endif // CONSTNESS_H
