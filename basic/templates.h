#ifndef TEMPLATES_H
#define TEMPLATES_H

#include <iostream>
#include <vector>
#include <cstring>

//Шаблонные функции и классы можно понимать как "шаблоны функций" и "шаблоны классов".
//Вместо прямого их использования в коде компилятор воспринимает их как образец, по которому
//нужно сконструировать требуемую функцию или класс.

//Шаблонные функции и классы позволяют обобщать одинаковый код, зависящий только от типа
//обрабатываемых элементов. Например, задача поиска максимального элемента в массиве
//по сути не зависит от типа элемента (только от того, можно ли его сравнивать с другими),
//но без использования шаблонных функций мы вынуждены были писать отдельные функции
//для поиска в массиве int, в массиве double, в массиве string и т.д.

//Таким образом, шаблонные функции и классы - это типонезависимые алгоритмы, которые компилятор
//использует для генерации реализации для конкретного типа.

//Терминология:
template <typename T> //список параметров шаблона
class Heap; //имя шаблона

template <typename T> //список параметров шаблона
class Heap<T*>; //Heap<T*> - идентификатор шаблона

template <>
class Heap<char*>; //имя шаблона + список аргументов шаблона

//Вместо слова typename в параметрах шаблона можно писать слово class.

//при использовании шаблона
Heap<int> aHeap; //Heap<int> - идентификатор шаблона, int - список аргументов шаблона
Heap<char*> aHeap2; //Heap<char*> - идентификатор шаблона

template <typename T> //список параметров шаблона
void print(const T &x) {} //print - имя шаблона

//Шаблоны функций
//---------------

//Шаблонная функция - это функция, тип аргументов которой (но необязательно) является
//неким обобщенным типом. Чтобы обозначить, что тип T является обобщенным, и не следует
//искать его объявление в заголовочных файлах, используют явное указание template <typename T>
template <typename Comparable>
const Comparable & findMax( const std::vector<Comparable> & a)
{
    int maxIndex = 0;
    for( size_t i = 1; i < a.size( ); ++i )
        if( a[ maxIndex ] < a[i])
            maxIndex = i;
    return a[ maxIndex ];
}
//такая функция годится для поиска в векторах с любым типом элементов, лишь бы для
//типа элемента была определена операция < (мы даем себе подсказку с помощью названия параметра шаблона).
//Так как тип Comparable может оказаться любым типом, необязательно простым, мы возвращаем из функции
//значение по константной ссылке, чтобы избежать возможного лишнего копирования.
struct IntCell
{
    int value;
};

void useFindMax()
{
    //vector - тоже шаблонный класс, поэтому я специализирую его аргументом нужного мне класса
    std::vector<int> v1( 37 );
    std::vector<double> v2( 40 );
    std::vector<std::string> v3( 80 );
    std::vector<IntCell> v4( 75 );

    // заполнение векторов

    //при вызове функции findMax происходит ее неявная специализация. Компилятор создает
    //экземпляр требуемой функции, основываясь на типе передаваемого вектора v1 - v4
    std::cout << findMax( v1 ) << std::endl; // OK: Comparable = int
    std::cout << findMax( v2 ) << std::endl; // OK: Comparable = double
    std::cout << findMax( v3 ) << std::endl; // OK: Comparable = string
    std::cout << findMax( v4 ) << std::endl; // Ошибка: operator< не определен для IntCell

    //функцию можно специализировать явно:
    std::cout << findMax<int>( v1 ) << std::endl; // OK: Comparable = int
}

//Параметром шаблона может выступать не только обобщенный тип, но и некоторая константа:
template<int size, typename T>
T* init(T t)
{
    T* arr = new T[size];
    for (int i=0; i<size; ++i) arr[i] = t;
    return arr;
}
//Первый параметр шаблона - размер массива, второй - тип элемента массива
//В функции мы создаем динамический массив размером size с элементами типа T и
//инициализируем все элементы значением t.
//Использование функции init
void useInit()
{
    int *a = init<10,int>(42);
    //или короче, с неявной спецификацией шаблонной функции:
    //int *a = init<10>(42);
    for (int i=0; i<10; ++i) std::cout << a[i] << " ";
    delete [] a;
}

//Явная специализация шаблона
//Предположим, у нас есть шаблонная функция, возвращающая размер типа в байтах:
template <typename T>
int numberOfBytes(T t)
{
    return sizeof(T);
}
//Для типа int она вернет 4, для типа double - 8, для класса - сумму размеров всех его членов.
//Но если мы попытаемся передать в функцию указатель, она вернет размер указателя, а не размер
//элемента, на который указывает указатель:
void useNumberOfBytes()
{
    std::cout << numberOfBytes("aa"); //выведет 4, так как "aa" - это строка типа char*
    //нам нужно, чтобы функция вернула 3 (количество символов + нулевой символ)
}
//Для решения этой проблемы добавим явную специализацию шаблона:
template <>
int numberOfBytes(const char* str)
{
    return strlen(str)+1;
}

//Используя явную специализацию, вы можете удалить ту специализацию функции, которая не имеет смысла:
template <typename T>
bool isGreater(T t1, T t2)
{
    return t1 > t2;
}
//Эта функция справится с целыми числами, с типом double, с символами char, со строками string.
//Но если в нее передать две булевы переменные, функция тоже отработает, но результат
//не будет иметь смысла: isGreater(true, true) - ?
//Удалим эту специализацию:
template <>
bool isGreater(bool t1, bool t2) = delete;
//Теперь код, использующий что-то наподобие isGreater(true, true), не скомпилируется.

//Практический пример полезной шаблонной функции:
//В проекте есть необходимость читать вектор элементов разного типа из файла и возвращать
//либо как вектор элементов double, либо как вектор элементов float.
//Если в файле могут быть записаны данные типа int, unsigned int, float, double, то мы получаем
//восемь различных функций:
std::vector<double> getDoubleVectorForInt();
std::vector<double> getDoubleVectorForUInt();
std::vector<double> getDoubleVectorForDouble();
std::vector<double> getDoubleVectorForFloat();
std::vector<float> getFloatVectorForInt();
std::vector<float> getFloatVectorForUInt();
std::vector<float> getFloatVectorForDouble();
std::vector<float> getFloatVectorForFloat();
//Это очень неудобно, более того, это восемь раз дублирует код. Я написал две шаблонные функции,
//которые обобщают все возможные типы:
template<typename T>
std::vector<T> readVector()
{
    std::vector<T> vec;
    //код чтения элементов типа T из файла
}
template<typename T, typename U>
std::vector<U> getVector()
{
    std::vector<T> vec = readVector<T>();
    std::vector<U> result(vec.size());
    for (size_t i = 0; i<vec.size(); ++i)
        result[i] = static_cast<U>(vec[i]);
    return result;
}
//Таким образом, вместо написания восьми функций, покрывающих только 8 возможных сочетаний типов,
//я написал две функции, покрывающие все возможные сочетания типов, включая другие типы данных.


//Шаблонные классы
//----------------

//Шаблонные классы пишутся аналогично шаблонным функциям.
//Класс для пары значений типа T:
template<class T>
class Pair
{
public:
    Pair();
    Pair(T firstValue, T secondValue);
    void setElement(int position, T value);
    T getElement(int position) const;
private:
    T first;
    T second;
};
//В отличие от шаблонных функций вы должны явно специализировать объекты шаблонного класса:
void usePair()
{
    Pair<int> intPair(1, 42);
    Pair<double> doublePair(20.0, 42.0);
    Pair<std::string> twoStrings("first", "second");

    //После объявления объектов шаблонного класса методы класса можно использовать без
    //указания типа элементов (то есть как шаблонные функции):
    twoStrings.setElement(0, "another");
    std::cout << doublePair.getElement(1);
}
//Если вы передаете объекты шаблонного класса в функцию или используете их в качестве
//элементов вектора, то постоянное прописывание специализации класса может утомлять.
//Поэтому обычно объявляют синонимы для специализаций:
using DoublePair = Pair<double>;
//или
typedef Pair<std::string> SPair;
//и дальше используем эти синонимы:
int getTotalLength(const std::vector<SPair> &vec)
{
    int result;
    for (const SPair &p: vec) {
        result += p.getElement(0).length();
        result += p.getElement(1).length();
    }
    return result;
}

//Задания:
//1. Перепишите функции, манипулирующие с массивом строк, и сделайте их шаблонными
//2. Объедините все эти функции в шаблонный класс
//3. Напишите функцию, которая возвращает количество вхождений заданной величины в вектор.
//4. Напишите класс, который реализует набор элементов (Set). Set - это контейнер,
//   в котором может находиться только один экземпляр объекта. Класс должен иметь методы:
//- конструкторы, включая копирующий конструктор и перемещающий конструктор
//- операторы присваивания - копирующий и перемещающий
//- деструктор, если нужен
//- метод добавления элемента в набор. Он должен возвращать успешность операции вставки
//- метод, проверяющий наличие элемента
//- метод, удаляющий заданный элемент
//- метод, возвращающий количество элементов
//- перегрузку операторов == и != для сравнения двух наборов
//- метод, возвращающий указатель на динамический массив, содержащий все элементы набора


#endif // TEMPLATES_H
