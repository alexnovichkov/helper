#ifndef LAMBDA_EXPRESSIONS_H
#define LAMBDA_EXPRESSIONS_H

#include <vector>
#include <iostream>
#include <algorithm>

//Лямбда-выражение - это анонимный функциональный объект, который способен захватывать
//переменные из своего окружения и выполнять определенный код для набора агрументов.

//Преимущества лямбда-выражений перед обычными функциями:
//1. Лямбда-выражения определяются непосредственно там, где используются, то есть не засоряют
//   глобальное пространство имен.
//2. Их проще передавать в функции и возвращать из функций.

//Недостатки лямбда-выражений:
//1. Так как лямбды представляют собой функциональный объект, то для каждой лямбды
//   "за кулисами" компилятором генерируется отдельный класс, что увеличивает размер программы.
//2. Хранение большого количества лямбда в оперативной памяти приводит к увеличению потребления.

//Синтаксис:
//    [capture](parameters)
//            mutable
//            -> T
//    {
//        body
//    }

//[capture] - список названий переменных (через запятую), которые определены в той же области видимости,
//в которой определена лямбда, и которые мы хотим "захватить", то есть иметь возможность
//использовать их внутри лямбды. Допускается захватывать переменные по значению [val], тогда
//в лямбда-выражение передается копия переменной val, или по ссылке [&val] (по
//константной ссылке [const &val]), тогда в лямбду передается ссылка на переменную val.
//Кроме того, можно захватить сразу всю область видимости по значению символом [=]
//или по ссылке символом [&].
//Если захватывать переменные не требуется, скобки следует оставить пустыми.

//Примеры:
// [](){}       Не захватывает ничего.
// [&](){}      Захватывает всё по ссылке.
// [=](){}      Захватывает всё по значению (копирует).
// [&x](){}     Захватывает только x по ссылке.
// [x](){}      Захватывает только x по значению.
// [&, x](){}   Захватывает всё по ссылке, кроме переменной x, которая захватывается по значению.
// [=, &x](){}  Захватывает всё по значению, кроме переменной x, которая захватывается по ссылке.
// [&, this](){}   Захватывает всё по ссылке, за исключением указателя this, который захватывается по значению.
// [x, x](){}   Ошибка: x захватывается дважды.
// [&, &x](){}  Ошибка: всё захватывается по ссылке, для переменной x захват по ссылке уже подразумевается.
// [=, =x](){}  Ошибка: всё захватывается по значению, для переменной x захват по значению уже подразумевается.
// [&this](){}  Ошибка: указатель this запрещено захватывать по ссылке.
// [&, =](){}   Ошибка: попытка захватить всё и по ссылке, и по значению.

//Пример захвата переменной:
void useCapture()
{
    //удаляем из вектора c все элементы, меньшие значения переменной x
    std::vector<int> c = {1, 2, 3, 4, 5, 6, 7};
    int x = 5;
    c.erase(std::remove_if(c.begin(), c.end(), [x](int n) { return n < x; }), c.end());

    //Алгоритм remove_if третьим аргументом принимает ссылку на функцию, которая определяет,
    //какие именно элементы следует удалять. Передача третьим аргументом лямбда-выражения
    //позволяет не объявлять отдельную функцию-предикат.
    //Так как мы хотим, чтобы значение переменной x использовалось внутри лямбда-выражения,
    //мы должны её захватить (по ссылке или по значению).
}

//(parameters) - аргументы лямбда-функции, так, как они обычно задаются для функций.
//Так как лямбда-выражения чаще всего используются в алгоритмах STL, под параметрами лямбд
//можно понимать как те элементы контейнеров, к которым применяется лямбда. Таким образом,
//можно определить тип и количество параметров лямбды (это будет зависеть от конкретного
//алгоритма).
//Аргументы лямбды должны соответствовать той операции, которая поддерживается
//используемым алгоритмом. Например,
// - при использовании алгоритмов, принимающих унарную функцию, лямбда должна иметь
//   один аргумент, тип которого соответствует типу элементов контейнера
// - при использовании алгоритмов, принимающих бинарную функцию, у лямбды должно
//   быть два аргумента.

//mutable - слово, которое добавляется, чтобы иметь возможность изменять значения
//переменных, захваченных по значению.
//Оно используется, в частности, в тех случаях, когда мы не можем захватить переменную
//по ссылке, но нам требуется изменять её значение внутри лямбды.

//-> T задает тип возвращаемого значения, если требуется явно указать его.
//Тип возвращаемого значения можно не указывать, если компилятор может вывести его
//из типа выражения в операторе return.

//Пример типа возвращаемого значения:
void useReturnType()
{
    auto convert = [](int n) -> double {return n;};
    std::cout << convert(2);
}

//Что происходит при компиляции файла, содержащего лямбда-выражения:
//1. Компилятор генерирует структуру следующего вида:
struct __lambda_name__ //(сильно упрощено)
{
    double operator()(int n /*аргументы лямбды*/) const { return n; /*тело лямбды*/}
};
//2. Объявляется переменная этого типа:
//__lambda_name__ convert;
//3. Вызов лямбда-выражения заменяется на применение оператора () этой переменной:
void useReturnType1()
{
    __lambda_name__ convert;
    std::cout << convert(2);
}


#endif // LAMBDA_EXPRESSIONS_H
