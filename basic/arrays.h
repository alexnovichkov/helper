#ifndef ARRAYS_H
#define ARRAYS_H

#include <iostream>

//Массив - это структура данных, позволяющая обрабатывать список однородных элементов.
//Массив позволяет дать одно имя всему списку элементов и обращаться к каждому элементу
//по его положению в списке - индексу.
//Индексация в массивах начинается с 0. Это значит, что первый элемент в списке array
//содержащем 10 элементов, будет иметь название array[0], а последний - десятый элемент -
//array[9].
//ЗАПОМНИТЕ: Последний элемент в массиве из n элементов имеет индекс n-1.

//Физически массивы в C++ используют тот факт, что в памяти компьютера можно подряд
//разместить n переменных одного типа (выделив им одинаковое число байт),
//и обращаться ко всей совокупности байт по первой переменной и по индексу.

//Почему индексация начинается с 0?
//индекс   0    1    2    3    4
//элемент  a[0] a[1] a[2] a[3] a[4]
//Индекс - это просто смещение переменной относительно начала массива.

//Массивы - это статические структуры. Как только вы выделили под такой массив память,
//вы уже не можете удалять или добавлять элементы. Кроме того, уже на этапе компиляции
//должен быть известен размер массива. Таким образом, массивы - это автоматические
//переменные, создаваемые на стеке.

void useArrays()
{
    using T = int;
//1. Объявление
//с известным на этапе компиляции размером
    T array[10];
    const int N = 10; //объявление массива размером, выраженным константой.
    T array2[N];

//с неизвестным на этапе компиляции размером - невозможно
    int M;
    std::cin >> M;
    T array1[M]; //запрещено!

//2. Инициализация

//массив целиком
    int array4[6] = {1,2,3,4,5,6}; // с указанием размера
    int array4_1[] = {1,2,3,4,5,6}; //без указания размера

//поэлементно
    int array5[5];
    array5[0] = 1;
    array5[1] = 2;
    //...
    array[4] = 5;

//3. Обращение к элементам
    int i=3;
    std::cout << array5[i];

//4. Итерация по элементам

//классическая - количество элементов N должно быть известно
    for (int i=0; i<N; ++i) {
        array[i] = i*i;
        std::cout << array[i]<<std::endl;
    }

//по всему массиву - количество элементов знать не нужно
//с изменением данных
    for (auto &x: array)
        x *= 2;

//без изменения данных
//  - простые типы
    for (auto x: array)
        std::cout << x;

//без изменения данных
// - сложные типы
    for (const auto &x: c)
        x.print();
}

//ЗАДАНИЯ

//1. В следующей записи :
double score[5];
//назовите:
//- имя массива
//- тип элементов
//- размер массива
//- значения, которые может принимать индекс в массиве

//2. Найдите ошибки в следующих объявлениях:
int x1[4] = { 8, 7, 6, 4, 3 };
int SIZE = 4; int x3[SIZE];

//3. Что выведет следующий код?
double a[3] = {1.1, 2.2, 3.3};
cout << a[0] << " " << a[1] << " " << a[2] << endl;
a[1] = a[2];
cout << a[0] << " " << a[1] << " " << a[2] << endl;

//4. Найдите ошибку:
int sampleArray[10];
for (int index = 1; index <= 10; index++)
    sampleArray[index] = 3 * index;

//5. Пусть дан массив целых чисел. Нам необходимо проверить, что все элементы в нём
//   расположены по возрастанию. Следующий код проверяет элементы и выводит в консоль
//   те из них, которые стоят не по порядку. Найдите ошибку в этом коде:
double a[10];
//<код для заполнения массива>
for (int index = 0; index < 10; index++)
    if (a[index] > a[index + 1])
        cout << "Array elements " << index << " and "
             << (index + 1) << " are out of order.";

//6. Напишите программу, которая заполнит массив двадцатью целыми числами, введенными
//   из консоли

//7. Пусть нам дан следующий массив:
int yourArray[7];
//Зная, что переменная типа int занимает 4 байта в памяти, ответьте:
//- сколько памяти будет выделено под массив?
//- сколько байт памяти будет отделять первый элемент массива от пятого?
//- если адрес первого элемента массива равен 2100000, чему будет равен адрес последнего
//  элемента?


//МАССИВЫ И ФУНКЦИИ

//Использование элементов массива как аргументов функции подчиняется общим правилам
//передачи аргументов в функцию:
//При call-by-value можно передавать отдельные элементы в функцию, сам массив при этом не изменится.
//(эта функция корректирует длительность отпуска в зависимости от стажа работы)
int getNewVacation(int daysOfVacation, int seniority)
{
    if (seniority>=10) return daysOfVacation+5;
    return daysOfVacation;
}
//При call-by-reference можно менять значения отдельных элементов массива:
void adjustVacation(int &daysOfVacation, int seniority)
{
    if (seniority>=10) daysOfVacation += 5;
}
//использование:
void calculateVacation()
{
    int vacation[] = {21, 21, 50, 21, 14}; //отпуска пяти сотрудников
    int seniority[] = {10, 5, 1, 9, 20}; //стаж работы пяти сотрудников
    for (int i=0; i<10; i++) {
        int newVacation  = getNewVacation(vacation[i], seniority[i]);
        std::cout << "Vacation for employee "<<i<<" is "<< newVacation<<std::endl;
    }

    //то же самое, но используя вторую функцию
    for (int i=0; i<10; i++) {
        adjustVacation(vacation[i], seniority[i]);
        std::cout << "Vacation for employee "<<i<<" is "<< vacation[i]<<std::endl;
    }
}

//При передаче в функцию массивов целиком необходимо обозначить, что вы передаете именно
//массив. Особенностью компилятора C++ является то, что при этом не происходит передачи
//информации о размере массива, и не существует механизма узнать размер:

void reverse(int array[5]); //это объявление не гарантирует, что передача массивов другой длины невозможна.
void reverse(int array[]); //длина массива не указана, и мы уже не может ее получить.

//При написании функции, принимающей массив, всегда прописывайте вторым аргументом
//размер этого массива:
void reverse(int a[], int n);   //Передаем в функцию массив и его размер

//При передаче массива в функцию не происходит копирования массива в новый локальный массив.
//Фактически массив ведет себя так, как если бы он был ссылкой:
int myArray[10] = {1,2,3,4,5,6,7,8,9,10};
reverse(myArray,10); //теперь myArray = {10,9,8,7,6,5,4,3,2,1}

//Как защитить элементы массива от изменения? Объявите аргумент функции константным:
void printArray(const double a[], int n)
{
    //Эта функция просто выводит в консоль элементы массива. Изменение массива не планируется
    //и нежелательно
    for (int i=0; i<n; i++) std::cout << a[i]<<" ";
}

//Возвращение из функции невозможно:

void firstNumbers()
{
    int result[255];
    for (int i=0; i<255; ++i)
        result[i] = i+1;
    //result - локальная переменная, и будет уничтожена вне функции,
    //то есть return не имеет смысла
    return result;
}

//ЗАДАНИЯ

//8. Напишите функцию, которая принимает массив чисел и прибавляет к каждому элементу
//   заданное число

//9. Определите, в каком случае желательно/можно добавить const к аргументу-массиву
void printArray(double a[], int size);  //печатает массив
void dropOdd(int a[ ], int size);  //обнуляет все нечетные элементы

//10. Напишите функцию, outOfOrder, которая проверяет массив на упорядоченность:
//    принимает массив вещественных чисел и возвращает индекс первого найденного элемента,
//    который расположен не в порядке возрастания. Размер массива не превышает 20.
//    Пример: для массива {1.2, 2.1, 3.3, 2.5, 4.5, 7.9, 5.4, 8.7, 9.9, 1.0}
//    функция должна вернуть 3.

//11. Напишите программу, которая читает до 10 букв из консоли и выводит их в обратном порядке.
//    Предусмотрите проверку, что введено не более 10 букв.

//12. Напишите программу, которая сортирует массив целых чисел пузырьковой сортировкой.
//    В программе должен быть предусмотрен ввод массива из консоли. Размер массива
//    не должен превышать 20.
//Пузырьковая сортировка: пусть у нас есть массив элементов. Пробежимся по элементам массива,
//обменивая местами все соседние неупорядоченные элементы. Понятно, что в результате
//самое большое число "всплывет" в конец массива. Значит, при следующем просмотре массива
//самый последний элемент можно не рассматривать - он уже стоит на своем месте.
//Проходим массив таким образом, пока у нас не останется единственный элемент - прерываем цикл.

//           Исходный массив
//           34  8   64  51  32  21  поменяны местами элементы
//           8   34  64  51  32  21    0 и 1
//           8   34  64  51  32  21    никакие
//           8   34  51  64  32  21    2 и 3
//           8   34  51  32  64  21    3 и 4
//           8   34  51  32  21  64    4 и 5, элемент 64 на своем месте
//           8   34  51  32  21  _64_  никакие
//           8   34  51  32  21  _64_  никакие
//           8   34  32  51  21  _64_  2 и 3
//           8   34  32  21  51  _64_  3 и 4, элемент 51 на своем месте
//           8   34  32  21  _51_ _64_ никакие
//           8   32  34  21  _51_ _64_ 1 и 2
//           8   32  21  34  _51_ _64_ 2 и 3, элемент 34 на своем месте
//           8   32  21  _34_ _51_ _64_ никакие
//           8   21  32  _34_ _51_ _64_  1 и 2, элемент 32 на своем месте
//           8   21  _32_ _34_ _51_ _64_ никакие, элемент 21 на своем месте


//ДИНАМИЧЕСКИЕ МАССИВЫ

//Стандартная проблема массивов заключается в том, что их размер должен быть известен
//не просто заранее, а уже на этапе написания программы. Мы уже не можем считать из консоли
//требуемый размер и выделить строго нужную память под массив. Мы вынуждены создавать
//массив большего размера.

//Всех этих проблем можно избежать, если использовать динамические массивы.
//Они построены на выделении памяти в куче: вместо того, чтобы создать массив на стеке,
//выделим достаточно оперативной памяти для хранения N элементов в куче, и сохраним
//указатель на первый элемент. Так как объявление указателя и выделение памяти -
//это разные операции, мы обходим ограничение компиляции. Но возникает новая проблема:
//необходимо вовремя освобождать выделяемую память, чтобы программа не поглощала память,
//которую она не использует.

//Динамический массив создается как указатель на переменную, являющуюся первым элементом
//в цепочке n элементов. Память под динамический массив выделяется в куче, а указатель
//на первый элемент - на стеке.

void useDynamicArrays()
{
/*
    Обычные массивы                        Динамические массивы
    ---------------                        --------------------
1. Объявление

с известным на этапе компиляции размером
    T array[10];                           T *array = new T[10];
    const int N = 10;                      const int N = 10;
    T array2[N];                           T array2 = new T[N];

с неизвестным на этапе компиляции размером
    невозможно                             int n; cin >> n;
                                           T array3 = new T[n];

2. Инициализация

массив целиком
    int array4[] = {1,2,3,4,5,6};          невозможно

поэлементно
    int array5[5];                         int *array5 = new int[5];
    array5[0] = 1;                         *array5 = 1;
    array5[1] = 2;                         *(array5+1) = 2;
    ...                                    ...
    array[4] = 5;                          *(array5+4) = 5;

3. Обращение к элементам
    array5[i]                              array5[i] или *(array5+i)

(в функциях, которым передается обычный массив, возможно
    обращение к элементам в стиле указателей)

4. Итерация по элементам

классическая - количество элементов N должно быть известно
         for (int i=0; i<N; ++i) {
           c[i] = ...;
           cout << c[i]<<endl;
         }

по всему массиву - количество элементов не нужно
  с изменением данных
    for (auto &x: c)                       невозможно
        x *= 2;

  без изменения данных
  - простые типы
    for (auto x: c)                        невозможно
        cout << x;

  без изменения данных
  - сложные типы
    for (const auto &x: c)                невозможно
        x.print();

5. Передача в функцию
    для изменения данных
    int reverse(int a[], int n);          int reverse(int *a, int n);
    без изменения данных
    int print(const int a[], int n);      int print(const int * a, int n);

6. Возвращение из функции

    невозможно:                            возможно:

    void firstNumbers(int n)               int *getFirstNumbers(int n)
    {                                      {
        невозможно создать массив
        с размером n                          int *result = new int[n];
        int result[255];                      for (int i=0; i<n; ++i)
        for (int i=0; i<n; ++i)                   result[i] = i+1;
            result[i] = i+1;                  return result;
        result - локальная переменная,     } // не забудьте потом очистить память
        и будет уничтожена вне функции,
        то есть return не имеет смысла
        return result;
    }

7. Уничтожение переменной
     автоматически при выходе              уничтожается только указатель,
     переменной из области видимости       выделенная память не очищается и не удаляется
     - ничего делать не нужно              - требуется вызывать
                                           delete [] c; c = nullptr;
    */
}

//Замечание:
//В C++ переменная-массив и указатель на переменную - это один и тот же тип данных.
//Этим, в частности, объясняется тот факт, что массив, переданный в функцию, теряет
//информацию о своем размере - потому что на самом деле в функции оказывается уже не массив,
//а указатель на первый его элемент

int sum(int array[], int n); //одна и та же функция, неразличимая компилятором
int sum (int *array, int N); //одна и та же функция, неразличимая компилятором

//Всё отличие обычных массивов от динамических заключается в том, что под элементы
//обычного массива используется память стека, а динамического - память кучи.

//поэтому в программе можно смешивать указатели и массивы:
int myArray[] = {1,2,3,4,5};
int *pointerToInt;
pointerToInt = myArray;
...
pointerToInt[2] = 1; //myArray = {1,2,1,4,5}

//ЗАДАНИЯ

//Перепишите задания 8, 10, 11, 12 таким образом, чтобы они использовали динамические массивы.


//Арифметика указателей
//---------------------

//Арифметика указателей - это возможность прибавить к значению адреса переменной единицу,
//и получить адрес следующей переменной. Очевидно, что так как указатель имеет конкретный
//тип (то есть указывает на переменную конкретного типа), то при использовании арифметики указателей:
//1. обе переменные должны иметь одинаковый тип
//2. обе переменные должны располагаться в памяти сразу одна за другой, без промежутка.

//Этим условиям полностью соответствуют только массивы - автоматические или динамические.
//То есть если у вас есть указатель на любой элемент массива, то прибавив 1 или вычтя 1 из
//значения указателя (не из значения переменной, на которую указывает указатель!), мы получим
//указатель на следующий или предыдущий элемент. Конечно, необходимо следить за выходом за
//границы массива: память за пределами области, выделенной под массив, может быть занята
//другими переменными, и ее изменение мжет быть чревато трудноуловимыми ошибками.

//Арифметика указателей:
void pointerArithmetic()
{
    int count = 10;
    double * vec = new double[count]; //динамический массив из 10 элементов, vec указывает на первый элемент
    double *vec1 = vec; //vec1 тоже указывает на первый элемент
    vec1++; //теперь vec1 указывает на следующий элемент
    double* vecEnd = vec+9; //vecEnd указывает на конечный элемент
    do  { //итерация по всем элементам массива, используя арифметику указателей
        std::cout << *vec << " ";
        vec++;
    } while (vec != vecEnd);
    delete [] vec;
}

double countSum(double *begin, double * end)
{
    double sum = 0;
    for (; begin <= end; begin++) {
        sum += *begin;
    }
    return sum;
}

double s = countSum(vec, vec+4);

//Операции, доступные в арифметике указателей:
//1. Увеличение указателя на n равносильно передвижению на n элементов вперед
//2. Уменьшение указателя на n равносильно передвижению на n элементов назад
//3. Сравнение указателей (p1 == p2 означает, что p1 и p2 указывают на один и тот же элемент)
//4. void* не работает с арифметикой: компилятор не знает, переменная какого размера сохранена
//   по этому адресу.

//Если указатель объявлен как константный, то арифметика к нему уже неприменима, хотя вы еще можете
//менять данные по этому адресу памяти:
double* const dd = nullptr; //бесполезный константный указатель


//Задачи:
//17. Заполнить массив числами double, посчитать синус каждого числа и вывести в виде таблицы
//    x     sin(x)
//18. Написать функцию, объединяющую содержимое двух динамических массивов. Она должна
//    принимать два динамических массива, необязательно одинаковой длины, и возвращать 
//    третий массив, состоящий из элементов сначала первого массива, потом второго массива
//    (конкатенация массивов).
//19. Написать функцию, нормализующую значения числового массива:
//    void normalise(double* data, int length);
//    то есть преобразование диапазона значений массива к [0..1]

//ПРОЕКТЫ

//1. Этот проект необходимо выполнить двумя способами: а) чисто интерактивным;
//б) через чтение файла с данными.

//Найдите в интернете или придумайте среднюю ежемесячную норму осадков для города, в котором
//вы живете (всего 12 цифр). Затем найдите или придумайте реальное количество
//выпавших осадков за последние 12 месяцев. Выведите в виде красивой таблицы в консоль
//(или в файл) количество осадков за последние 12 месяцев вместе с отклонением
//от среднего количества осадков. Таблица должна иметь строки вида:

//Месяц   Осадки, мм     Отклонение, мм
//-------------------------------------
//Январь  35             -21
//Февраль...

//В дополнение к таблице реализуйте создание файла svg с диаграммой, отражающей таблицу.
//Для каждого месяца в диаграмме должно быть два расположенных рядом столбца со средним
//уровнем осадков и с измеренным.

//В варианте а) все данные вводятся с клавиатуры, а таблица выводится в консоль.
//В варианте б) данные читаются из файла, таблица сохраняется в файл.
//------------------------------------------------------------------------------

//2. Шестнадцатиричные числа используют основание 16, то есть 16 цифр для записи числа.
//Первые 10 цифр - это 0123456789. Для цифры 10 используется A, для 11 - B, для 12 - С
//и т.д., вплоть до 15 - F. Например, число 21_10 в 16-ричной системе записывается как
//15_16, а число FF_16 - это 255_10.

//Напишите программу, которая позволяет складывать два 16-ричных числа. Используйте
//динамические массивы для хранения цифр числа.
//Сложение реализуйте по стандартному алгоритму сложения чисел столбиком.
//------------------------------------------------------------------------------

//3. Напишите программу, которая шифрует сообщение по следующему алгоритму:
//Пользователь вводит строку, которую необходимо зашифровать (состоящую из латинских
//букв и пробела) и число, равное смещению буквы в алфавите. Алгоритм строит новую
//строку, в которой каждый символ - это буква, сдвинутая на величину смещения вправо
//(если смещение положительно) или влево (если смещение отрицательно). Смещение букв
//циклическое - алфавит закольцован (смещение 3 для буквы 'Y' даст 'B').
//Предусмотрите опцию в программе, позволяющую раскодировать сообщение по шифру и смещению.
//Для хранения сообщения используйте динамический массив символов
//------------------------------------------------------------------------------

//4. Напишите программу, бронирующую места в самолете.
//Все забронированные места должны храниться в текстовом файле. Изначально при первом запуске
//программа проверяет, существует ли файл с бронированием. Если не существует, то создается
//файл вида
//1  A B C    D E F
//2  A B C    D E F
//...
//всего 30 рядов.
//Если такой файл существует, то содержимое файла выводится в консоль.
//Далее программа предлагает забронировать место: спрашивает ФИО человека и номер места.
//Пользователь вводит, например, Aaron Jacobson 3F. Программа помечает, что это место занято,
//заменяя F в третьем ряду на X. После этого новая схема рассадки сохраняется в прежний файл,
//а в конец файла отдельной строкой дописывается введенная пользователем информация.
//Пользователь должен иметь возможность бронировать столько мест, сколько ему требуется.
//------------------------------------------------------------------------------

//5. Игра "Жизнь" Джона Конвея








#endif // ARRAYS_H
