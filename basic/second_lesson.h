#ifndef SECOND_LESSON_H
#define SECOND_LESSON_H

//Программы манипулируют числами и символами. Всё, что вы видите на экране, всё, что
//содержат ваши данные - это числа и символы, складывающиеся в некоторое отражение
//реальной действительности.

//Для манипуляции числами и символами большинство языков программирования используют переменные.
//Переменная позволяет задать одной единице данных некое имя, по которому к этой единице данных
//можно обращаться. Далее мы будем говорить в основном о целочисленных переменных.

//В C++ любая используемая переменная должна иметь известный к моменту компиляции тип.
//Наиболее часто используемый тип - это целочисленный int, позволяющий хранить целое число,
//положительное или отрицательное.

//Каждой переменной в языке C++ отводится определенное число байт, которое требуется
//для хранения этой переменной в памяти. Размер переменной определенного типа зависит
//от платформы, для которой была скомпилирована программа. Так, на большинстве платформ
//переменная типа int занимает не меньше 32 бит, то есть 4 байта.

//Количество байт, то есть размер типа, определяет, какую информацию можно хранить в переменной
//этого типа. Так, ограничение типа int в 4 байта позволяет хранить в переменной int числа
//в диапазоне от -2147483648 до 2147483647. Если мы попытаемся записать в переменную int большее число,
//то произойдет т.н. переполнение типа, и в переменной окажется мусор.

int goodInt = 345; //OK, в переменную goodInt записано число 345
int i = 2147483649; //в переменной i записано не число 2147483649, а что-то еще

//В общем случае переменная - это некое имя адреса в памяти. Нам совершенно неважно, какой адрес
//в памяти выберет компилятор для ассоциации с переменной, хотя мы и можем его получить.
//Размер типа данных как раз и указывает, сколько ячеек в памяти будет отведено под
//переменную данного типа.

//Идентификаторы
//--------------

//Название переменной называется идентификатор. В C++ есть правила именования переменных:

//1. Идентификатор может содержать только цифры, латинские буквы, знак подчеркивания
//2. Идентификатор не может начинаться с цифры

//Так, i, x, my_variable, _private_value, Truck, BonusSalary - правильные идентификаторы

//12, 3x, 5%error, my.first.variable - недопустимые идентификаторы

//C++ - это регистрозависимый язык, то есть name и Name - это две различные переменные.
//(В Pascal это одна и та же переменная)

//3. Идентификатор не должен совпадать ни с одним из зарезервированных слов (ключевых). Ниже приведен
//полный список зарезервированных слов C++

//alignas     default       if         reinterpret_cast  try
//alignof     delete        inline     return            typedef
//asm         do            int        short             typeid
//auto        double        log        signed            typename
//bool        dynamic_cast  long       sizeof            union
//break       else          mutable    static            unsigned
//case        enum          namespace  static_assert     using
//catch       explicit      new        static_cast       virtual
//char        export        noexcept   struct            void
//class       extern        nullptr    switch            volatile
//const       false         operator   template          wchar_t
//const_cast  float         private    this              while
//constexpr   for           protected  thread_local
//continue    friend        public     throw
//decltype    goto          register   true

//Соглашения о именовании
//-----------------------

//Существует несколько соглашений об именовании переменных в программах на C++

//1. Соглашение в стиле языка C. Идентификатор начинается со строчной буквы, а отдельные слова
//в идентификаторе разделяются подчеркиваниями. Этот стиль принят в стандартной библиотеке std

int my_very_important_variable;

//2. Соглашение в стиле C++ (большинство платформ). Идентификатор начинается со строчной буквы,
//а отдельные слова в идентификаторе начинаются с заглавных букв

int myVeryImportantVariable;

//3. Соглашение в стиле Windows. Идентификатор начинается с заглавной буквы,
//отдельные слова в идентификаторе начинаются с заглавных букв

int MyVeryImportantVariable;


//Объявление переменных
//---------------------

//Любая переменная должна быть объявлена. Объявление переменной - это указание ее типа
//и придуманного имени, после которого следует точка с запятой

int x;
double value;
std::string lineOfCode;

//Допускается объявлять несколько переменных через запятую, если они имеют одинаковый тип:

int x, y, z;

//Тип переменной - это либо некий предопределенный тип (числовой, символьный, логический и т.д.),
//определенный в языке C++, либо ваш собственный тип, который вы добавили в программу
//(объявили).

//Перед названием переменной может быть довольно длинная последовательность символов,
//которая называется имя типа. Имя типа может включать не только непосредственно тип переменной,
//но и дополнительные квалификаторы типа. Это позволяет тонко настроить использование
//переменной в программе.

int x; //обычная целочисленная переменная
const int y = 10; //это уже константа, а не переменная
int *z; //это уже указатель на переменную

//- Дополнение -
//Синтаксис языка C++ довольно запутан в некоторых случаях, и идентификатор может оказаться
//включен внутрь имени типа

int (*(*foo)(double))[3]; //массив из трех указателей на указатели на функции с сигнатурой int foo(double);

//Здесь идентификатор - это foo, а всё остальное - это имя типа.

//- Дополнение 2 -
//Предположим, нам нужно объявить переменную U того же типа, что и переменная x, но мы не
//знаем точный тип переменной x:

decltype(x) U;

//Присвоение значений
//-------------------

//После того, как вы объявили переменную, вы можете присвоить ей значение, используя =

int x;
x = 42;

//Эти две строки можно объединить в одну:

int x = 42;

//Присваивать можно что угодно, что компилятор способен разобрать и вычислить, например,
//арифметическое выражение

int z = x * y; //значения переменных x и y перемножаются и полученное число присваивается
               //новой переменной

//Вы можете использовать один идентификатор как слева, так и справа от знака присваивания:

z = z + 6;

//Компилятор поймет это как: взять значение переменной z, прибавить к нему 6, присвоить полученное
//число переменной z, то есть значение z увеличится на 6.

//Литералы
//--------

//Значения, которые мы присваиваем переменным, и которые не являются результатом вычислений,
//называются литералами. В языке C++ существуют следующие типы литералов:

//1. Числовые
//1.1. Целочисленные : 42, -3, 0, 0xAB2, 0b1001
//1.2. Действительные: 42.1, -5.025, 4.1e-5, .0003,
//2. Символьные - это любые символы любых алфавитов: 'a', 'b', 'C', '-', '_', 'ф'.
//3. Строковые - это любые последовательности символов в двойных кавычках:
//"line 1", "very long text", "сообщение пользователю".
//4. Булевы (логические): true, false
//5. nullptr

//Эти литералы позволяют добавить в программу некоторые данные, которые известны на
//этапе написания программы. Все литералы, которые мы запишем в исходный текст, в итоге попадут в
//исполняемый файл в специальный раздел файла, называемый разделом данных. Оттуда они будут
//копироваться процессором в переменные, то есть в другие области памяти, выделенной программе.

//Неинициализированные переменные
//-------------------------------

//Если мы объявим переменную, но не присвоим ей значение, она останется неинициализированной.
//Это значит, что под переменную была выделена область памяти, но в эту область памяти
//ничего не было записано. Там может оказаться любой мусор, остатки другой, уже закрытой, программы,
//просто какие-то случайные биты. Неинициализированная переменная примет в этом случае
//то значение, которое процессор извлечет из этой области памяти. При разных запусках
//программы неинициализированная переменная может принимать различные значения, потому
//что операционная система не гарантирует, что вашей запущенной программе будет выделена
//одна и та же область памяти.

//Альтернативный синтаксис инициализации
//--------------------------------------

//С++ позволяет использовать другой синтаксис для инициализации переменной с помощью
//литерала или выражения:

int t(3), k(2);
double d(3.333);

//Такой синтаксис позволяет ясно отделить _инициализацию_ переменной при ее объявлении
//от _изменения значения_ этой переменной при дальнейшем ее использовании:

int m(0); //объявили и инициализировали
m = 4; //изменили

//Дополнительно:
//Еще один альтернативный синтаксис инициализации
//-----------------------------------------------

//В стандарте языка C++11 появилась возможность инициализировать переменные с помощью
//фигурных скобок:
int kk{-7};
double dd{1.23e-5};
//Такая инициализация является универсальной, и подходит для инициализации:
//- простых типов данных (int, double, char, bool и т.д.)
//- экземпляров классов
//- контейнеров
//- не копируемых объектов
//и исправляет множество странностей в синтаксисе C++, накопившихся за десятилетия развития языка.

//Совет: всегда инициализируйте свои переменные фигурными скобками, если вы компилируете код
//компилятором, поддерживающим стандарт C++11.

//ЗАДАНИЯ

/*
1. Объявите две переменные с именами feet и inches целочисленного типа.
   Обе должны быть инициализированы нулем.
2. Объявите две переменные - целочисленную count и вещественную distance.
   Присвойте нулевое значение переменной count и значение 1.5 переменной distance.
3. Запишите инструкцию, которая позволит присвоить переменной sum значение, равное сумме
   значений переменных n1 и n2.
4. Запишите инструкцию, которая увеличит значение переменной length на 8.3.
   Какой тип должна иметь переменная length?
5. Запишите инструкцию, которая увеличит значение переменной product в n раз.
6. Напишите программу, в которой объявите пять неинициализированных переменных.
   Выведите из значения в консоль. Запустите программу несколько раз.
7. Придумайте подходящие идентификаторы для выражения:
   a. скорости автомобиля
   b. стоимости часа работы сварщика
   c. максимального набранного балла на экзамене
   d. количества метров в футе
   e. дня недели, дня месяца
*/

#endif // SECOND_LESSON_H
