#ifndef POLYMORPHISM_H
#define POLYMORPHISM_H

#include <string>
#include <iostream>
#include <vector>

using namespace std;

//В этом файле описываются простые случаи наследования и полиморфизма.

//Одна из наиболее сильных возможностей C++ - это использование производных классов.
//Говорят, что класс B является производным от класса A, если B добавляет в класс A
//дополнительный функционал. Примеры:

//Базовый класс - это класс, описывающий лицензируемое транспортное средство (любое).
//Тогда производным классом может быть класс, описывающий легковые автомобили.

//Базовый класс - это класс, описывающий банковскую карту. Производные классы описывают
//дебетовую карту и кредитную карту.

//Наследование позволяет сначала описать общий функционал, который имеется у разных типов,
//а затем уточнить поведение объектов отдельных типов. Наследование - это отношения
//типа "является": Легковой автомобиль является транспортным средством, кредитная карта -
//это банковская карта. Квадрат и круг - это геометрические фигуры и т.д.

//Терминология:
//Базовый класс (родительский класс)
//Производный класс (дочерний класс)

//Наследование следует отличать от композиции: наследование выражает отношения между
//объектами типа "является", композиция - отношения между объектами типа "включает".
//Пример: легковой автомобиль является автомобилем, и включает раму, кузов, 4 колеса и т.д.

//Пусть у нас объявлен класс File:

class File
{
public:
    File(const string &name) : name(name) {
        //открытие файла
    }
    long long int fileSize() const {
        return 0; //заглушка, пока что ничего не делает
    }

private:
    string name;
    int handle;
};

//Этот класс не описывает никаких особенностей файла, который мы открываем, кроме длины.
//Пусть теперь нам нужно работать с файлами mp3. Простейший вариант - наследовать
//его от класса File

class Mp3File: public File
{
public:
    //Так выглядит конструктор дочернего класса
    Mp3File(const string &name) : File(name) {
        //открытие файла и подсчет длины в секундах
    }
    long long lengthInSeconds() const {return length;}
private:
    long long length;
};

//Теперь, создав объект класса Mp3File, мы можем вызывать методы как класса Mp3File,
//так и родительского класса File

void useInheritance() {
    Mp3File mp3("file name.mp3");
    cout << mp3.fileSize()<<" "<<mp3.lengthInSeconds();
}

//При создании объекта дочернего класса в памяти сначала создается объект родительского класса,
//а потом к нему "добавляются" члены дочернего класса. И обратно: при уничтожении
//объекта дочернего класса сначала будут уничтожены члены дочернего класса, а потом члены родительского.
//Пример:

class ParentClass
{
public:
    //конструктор
    ParentClass() {
        cout << "parent class created"<<endl;
    }
    //деструктор
    ~ParentClass() {
        cout << "parent class destroyed"<<endl;
    }
};

class ChildClass : public ParentClass
{
public:
    //конструктор
    ChildClass() : ParentClass() {
        cout << "child class created"<<endl;
    }
    //деструктор
    ~ChildClass() {
        cout << "child class destroyed"<<endl;
    }
};

class CChildClass : public ChildClass
{
public:
    //конструктор
    CChildClass() {
        cout << "second child class created"<<endl;
    }
    //деструктор
    ~CChildClass() {
        cout << "second child class destroyed"<<endl;
    }
};

void creatingAndDestroying()
{
    CChildClass a;
}

//Из этого правила следует один важный вывод:
//Производный класс должен отвечать только за собственные данные, оставляя базовому классу
//самому отвечать за свои данные. Пример:

//Класс, который открывает файл на чтение
class os_file
{
public:
    os_file(const string& name)
        : file_name(name), file_handle(open_file(name))
    {}

    ~os_file() { close_file(file_handle); }
    int open_file(const string &name) {
        //открытие файла
        return 0;
    }
    void close_file(int handle) {
        //закрытие файла
    }
private:
    string file_name;
    int file_handle;
};
//Дочерний класс:
class mp3_file : public os_file
{
public:
    //Здесь уже мы не прописываем методы open_file и close_file, так как берем их из родительского.
    mp3_file(const string& name) : os_file(name) {
    }
    ~mp3_file() {
        /* clean up mp3 stuff*/

        //Если мы здесь вызовем функцию close_file, то тем самым нарушим работу
        //деструктора родительского класса. Мы и не обязаны делать это - деструктор родительского
        //класса будет вызван автоматически после вызова этого деструктора.
    }
};


//Скрытие имен в дочернем классе - переопределение членов-функций
//---------------------------------------------------------------
//Если в дочернем классе определена функция (B::f(int)), сигнатура которой полностью совпадает с
//сигнатурой функции из родительского класса (A::f(int)), то функцию A::f(int) уже нельзя
//вызвать из объекта дочернего класа, так как она "скрыта". Таким образом возможно
//менять поведение объектов дочернего класса, если поведение, определенное в родительском классе,
//нас не устраивает.

class A
{
public:
    void f(int x) {
        std::cout << x<< endl;
    }
};

class B: public A
{
public:
    void f(int x) {
        std::cout << x*2 << endl;
    }
};

//Если вам требуется выполнить функцию базового класса, которая была переопределена в производном классе,
//то есть использовать объект производного класса, как будто он является объектом базового класса,
//то необходимо явно указать, что вы обращаетесь к функции базового класса:
// b.A::f(2);

void hiding()
{
    A a;
    a.f(2); // в терминал будет выведено "2"
    B b;
    b.f(2); // в терминал будет выведено "4"
    //вызов функции базового класса
    b.A::f(2); // в терминал будет выведено "2"
}



//Переопределение не следует путать с перегрузкой. Перегрузка - это добавление функций-членов
//в производный класс, которые имеют то же самое имя, но иной набор аргументов. При переопределении
//мы добавляем в производный класс функцию с точно такой же сигнатурой, что и у функции родительского
//класса.

class C : public B
{
public:
    void f(int x) {
        std::cout << "переопределенная функция" << endl;
    }
    void f(int x, int y) {
        std::cout << "перегруженная функция" << endl;
    }
};

void hidingAndOverloading()
{
    C c;
    c.f(2); //вызов переопределенной функции
    int x=2;
    c.f(x, 3); //вызов перегруженной функции
}



//Указатели и ссылки на дочерние классы
//-------------------------------------
//В C++ вы можете получить указатель на то место памяти, в котором расположен объект,
//используя оператор &. Указатель имеет тип, поэтому компилятор предполагает,
//что указатель указывает на адрес памяти, по которому расположен объект именно такого типа.

string s = "abcde";
string *pointerToS = &s; //тип указателя - адрес переменной типа string

//Аналогично вы можете получить ссылку на объект, и эта ссылка будет синонимом для этого объекта,
//то есть операции на ссылке отразятся на исходном объекте.
//Указатель (или ссылка) на объект производного класса может неявно приводиться к указателю (ссылке)
//на объект базового класса. Это значит, что если вы написали функцию, принимающую в качестве аргумента
//объект базового класса, и используете данные и методы базового класса, то вы можете передать в функцию
//объект производного класса. Функция не будет знать, что этот объект является объектом
//производного класса, и не будет видеть добавленные методы и данные.
//Такое поведение называется slicing - "срезка" объекта до базового.

//Пример:
//Рассмотрим классы A и B, объявленные выше. Пусть у нас объявлена функция, принимающая ссылку на класс A
void doWithA(A &a)
{
    a.f(3);
}

//Если передать в функцию doWithA объект класса B, то в терминал будет выведено число 3
void useReferenceToBaseClass()
{
    B b;
    doWithA(b); //Вызываем функцию, принимающую объект базового класса,
                //но передаем объект производного класса
}

//Если у вас есть указатель на объект базового класса, то вы можете преобразовать его
//в указатель на объект производного класса с помощью static_cast
void staticCasting(A *a)
{
    B *b = static_cast<B*>(a);
    b->f(3); //выведется 6
}
//однако если переданный в функцию объект не является объектом производного или базового класса,
//то static_cast вернет испорченный объект (static_cast срабатывает всегда, даже если
//приведение указателя к требуемому типу невозможно)
void badCasting()
{
    ParentClass o;
    B *b = static_cast<B*>(&o); //сработает, указатель b указывает на неправильный объект
    b->f(3); //на этой строке программа может упасть
}

//Если такое поведение - приведение указателя на производный класс к указателю на базовый класс -
//вас не устраивает, то можно реализовать класс как полиморфный, о чем будет рассказано ниже.



//Виды доступа - private, protected, public
//-----------------------------------------
//Если в родительском классе есть члены, объявленные как private, то даже производные классы
//не имеют доступа к таким членам. Таким образом, члены private являются приватными всегда.
//Чтобы обойти это ограничение, то есть предоставить доступ к членам класса только производному
//классу, но ничему другому, существует слово protected:

//Член родительского класса:              Кто имеет к нему доступ
//-------------------------               -----------------------
//public                                  все объекты снаружи класса, все производные классы
//protected                               только производные классы
//private                                 никто

//Слово protected используется также для явного указания "Этот член класса намеренно сделан
//protected, потому что я намереваюсь переопределять его в производных классах".

//Пример: В графической библиотеке Qt члены классов, ответственные за обработку событий мыши
//и клавиатуры, объявлены как protected, чтобы программист, реализующий собственные функции
//реагирования на нажатия кнопок мыши и клавиатуры, знал, что эти методы следует переопределить:

//отвечает за описание события нажатия кнопки мыши
class QMouseEvent
{
public:
    //метод, возвращающий нажатую кнопку
    int button() const;
};
//базовый класс для всех объектов на экране
class QWidget
{
protected:
    virtual void mousePressEvent(QMouseEvent *event); //реализация этого метода в классе QWidget
                                                      //не делает ничего. Этот метод следует переопределить
};
//класс, который может отлавливать нажатия мыши
class ClickableWidget: public QWidget
{
protected:
    //переопределяем метод, отвечающий за обработку нажатий мыши
    virtual void mousePressEvent(QMouseEvent *event)
    {
        if (event->button()==0) {
            //если нажата левая кнопка мыши, то совершаем какие-то действия
        }
    }
};

//Дополнительно:
//С помощью изменения уровня доступа вы можете убрать члены базового класса из доступа в производном классе,
//или наоборот, предоставить доступ к методу, который в базовом классе был скрыт:

class Class1
{
public:
    void publicFunction();
protected:
    void functionToOverride();
private:
    void hiddenFunction();
};

class Class2: public Class1
{
public:
    using Class1::functionToOverride; //теперь functionToOverride видна как public
protected:
    using Class1::publicFunction; // теперь эта функция скрыта
    //using Class1::hiddenFunction; Ошибка: невозможно изменить доступ к private членам
};



//Функции, которые не наследуются
//-------------------------------

//При наследовании родительского класса есть ряд членов-функций, которые не наследуются -
//их нужно объявлять заново. Это:
//- конструкторы
//- деструктор 
//- приватные методы класса
//- копирующий конструктор и конструктор перемещения
//- оператор присваивания (operator=) и оператор перемещения (operator=&&)
//Такое поведение реализовано в C++ для того, чтобы позволить программисту самостоятельно
//реализовать эти функции, так как их реализация сильно зависит от того, что именно
//программист добавляет в дочерний класс.


//Как правильно писать Big Five для дочерних классов
//--------------------------------------------------

//Пусть базовый класс является хранилищем динамического массива целых чисел.
//Пропишем в нем весь набор Big Five
class BaseClass
{
public:
    //конструктор по умолчанию
    BaseClass() {}
    //конструктор с параметром
    BaseClass(size_t size) : array{new int[size]}, size{size}
    {}
    //деструктор
    ~BaseClass() {
        delete[] array;
    }
    //копирующий конструктор
    BaseClass(const BaseClass & other) : array{new int[other.size]}, size{other.size}
    {
        memcpy(array, other.array, size); //копируем элементы массива в новый массив
    }
    //перемещающий конструктор
    BaseClass(BaseClass && other) : array{other.array}, size{std::move(other.size)} //копируем указатель
    {
        other.array = nullptr; //обнуляем указатель на старый объект
    }
    //копирующий оператор присваивания
    BaseClass & operator=(const BaseClass & other)
    {
        if (this != &other) { //не присваиваем объект самому себе
            //удаляем старый массив
            delete [] array;
            //копируем массив из other
            size = other.size;
            array = new int[size];
            memcpy(array, other.array, size);
        }
        return *this;
    }

    //оператор перемещения
    BaseClass &operator=(BaseClass && other)
    {
        //удаляем старый массив
        delete [] array;
        //перемещаем массив из other
        size = std::move(other.size);
        array = other.array;
        other.array = nullptr;
        return *this;
    }
private:
    int *array = nullptr;
    size_t size = 0;
};

//Теперь создадим дочерний класс, который будет хранить дополнительную информацию о динамическом массиве -
//источник данных.

class NewClass : public BaseClass
{
public:
    enum Source {
        File = 0,
        Net = 1,
        Local = 2
    };
    //конструктор по умолчанию
    NewClass() : BaseClass() {}
    //добавляем конструктор, сигнатура которого совпадает с сигнатурой конструктора базового класса.
    //Всегда дублируйте все конструкторы базового класса в производном классе
    NewClass(size_t size) : BaseClass(size) {}
    //дополнительный конструктор с параметром, специфичным для производного класса
    NewClass(Source source, size_t size) : BaseClass(size), source{source} {}
    //деструктор
    ~NewClass() {
        //Если деструктор базового класса работает правильно, то нет необходимости объявлять
        //деструктор производного класса, так как при уничтожении объекта производного класса
        //деструктор базового класса будет вызван автоматически. Однако мы все же можем
        //явно вызвать деструктор, используя строку ниже:
        BaseClass::~BaseClass(); //вызываем деструктор базового класса
    }
    //копирующий конструктор
    NewClass(const NewClass & other) : BaseClass(other), source{other.source}
    {}
    //перемещающий конструктор
    NewClass(NewClass && other) : BaseClass(other), source{std::move(other.source)}
    {}
    //копирующий оператор присваивания
    NewClass & operator=(const NewClass & other)
    {
        //первым делом вызываем оператор присваивания из базового класса
        BaseClass::operator=(other);
        //копируем оставшиеся данные
        source = other.source;
        return *this;
    }
    //оператор перемещения
    NewClass &operator=(NewClass && other)
    {
        //первым делом вызываем оператор перемещения из базового класса
        BaseClass::operator=(other);
        //перемещаем оставшиеся данные
        source = std::move(other.source);
        return *this;
    }

private:
    int source = File;
};

//Класс NewClass, объявленный выше, демонстрирует переопределение тех методов, которые
//не наследуются. Однако он добавляет только один новый член - целое число source, и компилятор
//знает, как с ним обращаться. Таким образом:
//Если ваш производный класс добавляет только простые члены данных, для которых компилятор
//сам может сгенерировать эти функции, то вам не обязательно переопределять Big Five,
//вы можете оставить их реализацию на откуп компилятору.


//Множественное наследование
//--------------------------

//Множественное наследование - это механизм, позволяющий агрегировать в одном производном классе
//методы и открытые данные нескольких базовых классов:

class base1 { public: void a(); };
class base2 { public: void b(); };
class derived : public base1, public base2
{
public:
    // получает и a, и b
};

//Множественное наследование используется обычно в тех случаях, когда базовые классы
//выступают в роли "кирпичиков", каждый из которых предоставляет свою часть функциональности,
//и которые можно комбинировать между собой, получая новые классы. Типичный пример -
//использование интерфейсов (об этом здесь речь не идет, так как это продвинутая тема).

//Особое внимание следует уделять случаям, когда все базовые классы имеют одинаковые члены
//(данные или методы). Производный класс унаследует их ВСЕ, а не только один из вариантов.
//Пример:
class Base1 { public: int x = 1; int y = 10;};
class Base2 { public: int x = 2; int z = 20;};
class Derived : public Base1, public Base2
{
public:
    // получает оба варианта x
};
//При использовании объекта такого производного класса можно обратиться к каждому
//экземпляру переменной x, используя ее полное имя:
void useMultipleInheritance()
{
    Derived d;
    std::cout << d.Base1::x << " "<< d.Base2::x; //уточнили, к какой именно переменной x мы обращаемся.
    std::cout << d.Base1::y << " "<< d.z;
}


//Полиморфизм и виртуальные методы
//--------------------------------

//Полиморфизм - это возможность ассоциировать разные смыслы с одним и тем же именем,
//используя механизм, известный как позднее связывание. Позднее связывание - это ключевая
//концепция объектно-ориентированного программирования. Полиморфизма не существовало бы
//без позднего связывания с помощью _виртуальных функций_.

//Виртуальная функция - это функция, которую можно использовать ДО того, как она будет определена.
//Например, в графической программе могут использоваться разные фигуры - прямоугольники,
//круги, овалы и т.д. Каждая фигура - это объект отдельного класса. Например, класс Rectangle
//может иметь данные о высоте, ширине и центральной точке, тогда как классу Circle
//достаточно радиуса и центральной точки. В программе с хорошим дизайном все эти классы
//скорее всего будут унаследованы от общего базового класса Figure.

//Теперь, предположим, нам нужен метод, отвечающий за отрисовку фигуры на экране. Каждый вид фигуры будет
//отрисовываться по-разному, то есть каждый класс будет иметь свою реализацию такого метода.
//Однако все эти методы можно назвать одинаково: draw(). Если r - объект класса Rectangle,
//с - объект класса Circle, то вызовы r.draw() и c.draw() будут использовать разный код
//для отрисовки фигуры.

//Базовый класс Figure может иметь методы, которые применимы к любым видам фигур. Например,
//метод center(), который перемещает фигуру в центр экрана, стирая ее на старом месте
//и перерисовывая ее в центре экрана. Метод Figure::center() может использовать функцию
//draw(), чтобы перерисовать фигуру в центре. Однако здесь возникает проблема:
//метод center() использует метод draw(), который реализован по-разному в каждом производном классе.
//Однако мы вызываем draw в методе базового класса, который ничего не знает о производных классах.
//Вопрос: как дать понять компилятору, что при вызове унаследованной функции center() в каждом
//производном классе он должен вызывать метод draw(), специфичный для каждого типа объекта?

struct Figure {
	virtual void draw() {} //пустой, ничего не делает
    void center() {
        //1. убрать фигуру с экрана
        //2. изменить центр фигуры
        //3. отрисовать фигуру. Вопрос: как вызвать нужный метод draw(), переопределенный в производных классах?
    }
};
struct Rectangle : Figure {
    int height;
    int width;
    std::pair<int, int> centerPoint;
    void draw() {//Переопределенный метод Figure::draw()
        //отрисовать прямоугольник
    }
    //Унаследованный метод center()
};
struct Circle: Figure {
    int radius;
    std::pair<int, int> centerPoint;
    void draw() {//Переопределенный метод Figure::draw()
        //отрисовать круг
    }
    //Унаследованный метод center()
};

//Ответ: объявить виртуальную функцию Figure::draw():
//virtual draw();
//Тем самым мы даем знать компилятору: "Я не знаю, как реализована функция draw(). Подожди,
//пока вызов этой функции встретится в коде, и вызови соответствующую имплементацию
//из объекта класса. А пока что удовольствуйся пустым объявлением".
//Этот механизм - ждать, пока имплементация метода неизвестна до выполнения программы -
//и называется поздним связыванием.
//Виртуальную функцию можно понимать и следующим образом: при вызове метода draw()
//в методе базового класса, если у производного класса тоже есть такой метод (переопределенный),
//то переопределенный вариант предпочтительнее.

//Пример:
//Пусть нам требуется вести базу продаж для магазина. Мы хотим сделать
//программу гибкой, но пока не знаем, продажи какого типа нам понадобятся в дальнейшем.
//Пусть сначала у нас есть только обычные продажи покупателям, которые приходят в магазин
//и покупают единственный товар. Позже нам может понадобиться хранить в базе продаж
//продажи со скидкой, продажи наложенным платежом и т.д. Все эти продажи будут включать
//базовую цену продукта и итоговый счет, выставленный покупателю. Для простых продаж
//счет будет содержать только базовую цену товара. Для продажи со скидкой нужно еще
//учесть величину скидки, и т.д. Программа будет также иметь возможность расчета
//выручки за день (суммы всех счетов), средней величины счета за день и т.д.
//Все эти величины можно рассчитать, зная величину счета для каждого вида продажи,
//но мы пока не определились, какие виды продаж мы добавим в программу. Для решения
//этой проблемы объявим метод, выставляющий счет, виртуальным. Тем самым мы сможем заранее
//написать функции, использующие этот метод, не обращая внимание на то, с каким видом продажи
//мы имеем дело. Это также позволит нам добавлять другие виды продаж (оптовые, к примеру),
//уже имея работающую программу, и не переписывать код всех общих методов.
//Для простоты будем считать, что покупатель покупает ровно 1 штуку товара.
//Класс Sale будет базовым для всех типов продаж, и будет представлять обычную продажу
//за полную стоимость товара без скидок, наценок и под.

//Разделим определение класса на два файла - интерфейс и реализацию.

//Интерфейс класса, который должен быть сохранен в заголовочном файле sale.h
class Sale
{
public:
    Sale();
    Sale(double price);
    virtual double  bill() const; //<- метод, выставляющий счет, объявлен виртуальным
    //Возвращает разницу в стоимости, если купить другой товар
    double savings(const Sale& other) const;
protected:
    double price;

};
//Сравнивает две продажи.
bool operator <(const Sale& first, const Sale& second);

//Реализация класса, которая сохраняется в файле sale.cpp
//#include "sale.h"

//конструктор по умолчанию.
Sale::Sale() : price(0)
{}

//конструктор с параметром-ценой товара
Sale::Sale(double price) : price(price)
{}

//метод, выставляющий счет, просто возвращает стоимость товара
//Заметьте - в файле реализации уже не нужно писать слово virtual
double Sale::bill() const
{
    return price;
}

//метод, возвращающий разницу в стоимости двух товаров
double Sale::savings(const Sale& other) const
{
    return (bill() - other.bill());
}

//Оператор <, объявленный в заголовочном классе
bool operator <(const Sale& first, const Sale& second)
{
    return (first.bill() < second.bill());
}

//Заметьте, что метод savings и оператор < используют метод bill. Так как этот метод
//объявлен виртуальным, то мы позже сможем объявить классы, производные от Sale,
//переопределить для них метод bill, и унаследованный метод savings, а также оператор <
//будут вызывать версию метода bill, соответствующую объекту производного класса.
//Например, добавим в программу поддержку продаж со скидкой

//объявление класса DiscountSale.
class DiscountSale : public Sale
{
public:
    DiscountSale();
    //Скидка выражается в процентах от цены
    DiscountSale(double price, double discount);
    //объявляем метод виртуальным. Это необязательно, так как метод базового класса уже объявлен виртуальным.
    //добавляем слово override, чтобы показать, что мы переопределяем виртуальную функцию базового класса.
    virtual double bill() const override;
protected:
    double discount;
};

//Реализация класса DiscountSale
DiscountSale::DiscountSale() : Sale(), discount(0)
{}
DiscountSale::DiscountSale(double price, double discount)
    : Sale (price), discount(discount)
{}
double DiscountSale::bill ( ) const
{
    double fraction = discount/100;
    return (1 - fraction)*price;
}

//Как это работает? Если мы добавляем в базу две продажи со скидкой, то есть создаем две
//переменных типа DiscountSale, b1 и b2, то при расчете разницы в их стоимости
//мы будем использовать метод, определенный в базовом классе, который был скомпилирован еще до того,
//как мы добавили в программу поддержку продаж со скидкой. Этот метод ничего не знает
//о типе DiscountSale, однако благодаря позднему связыванию при вызове метода b1.savings(b2)
//будет вызван метод bill, переопределенный в производном классе, а не базовый метод класса Sale.

//Пример использования классов продаж:
void salesExample()
{
    Sale simple(10.00); //одна штука за $10.00
    DiscountSale discount(11.00, 10); //одна штука за $11.00 со скидкой 10%

    if (discount < simple)
    {
        cout << "Товар со скидкой дешевле.\n";
        cout << "Выгода равна $" << simple.savings(discount) << endl;
    }
    else
        cout << "Товар со скидкой не дешевле.\n";
}

//Подведем итоги:
//1. Если вы хотите, чтобы методы базового класса вызывали методы, переопределенные в
//   производных классах, вы объявляете метод базового класса виртуальным.
//2. Переопределенный метод в производном классе объявлять виртуальным необязательно,
//   так как такой метод становится виртуальным автоматически. Но это хорошая практика,
//   позволяющая вам отслеживать особенности наследования.
//3. Хорошая практика - объявлять переопределенный метод производного класса со словом override,
//   которое является подсказкой вам, что вы намеренно переопределили виртуальный метод
//   базового класса. Более того - если вы попытаетесь добавить override к переопределенному
//   невиртуальному методу, компилятор выдаст ошибку.
//4. Слово virtual добавляется только к объявлению функции, но не к определению. Аналогично -
//   слово override.

//Таблица виртуальных функций (необязательный раздел)
//---------------------------

//Если виртуальные методы - это так хорошо, почему бы не объявлять все методы класса виртуальными?
//На этот вопрос есть хороший ответ: таблица виртуальных функций.
//Именно наличие таблицы виртуальных функций позволяет компилятору осуществить позднее связывание
//объявления и определения метода. Она представляет собой список виртуальных функций,
//который добавляется к каждому классу, в котором есть виртуальные функции. Кроме того,
//в каждый объект класса добавляется (невидимый вам) указатель на таблицу виртуальных функций.
//Как происходит позднее связывание:
//---------------------------------
//1. Компилятор создает таблицу vtable, содержащую указатели на виртуальные методы, и добавляет ее
//   к скомпилированному коду базового класса.
//2. При создании объекта базового класса к объекту добавляется указатель vptr на vtable.
//3. При вызове виртуального метода компилятор по указателю vptr ищет в таблице vtable подходящий метод
//   и вызывает его.
//4. В производном классе, унаследованном от базового класса, есть своя таблица vtable, заполненная
//   указателями на переопределенные виртуальные методы производного класса. Если производный класс
//   не переопределяет виртуальный метод базового класса, то в таблицу vtable будет добавлен
//   указатель на виртуальный метод базового класса.
//5. При вызове виртуального метода производного класса компилятор ищет подходящий метод
//   в таблице vtable. Это может оказаться указатель на переопределенный метод производного класса,
//   или указатель на метод базового класса.

//Хранение в памяти таблиц виртуальных функций и необходимость искать функцию в таблице
//при каждом вызове метода приводят к замедлению работы программы. Поэтому обычно
//виртуальными делают только необходимый минимум методов.


//Виртуальные методы и указатели (ссылки) на объекты
//--------------------------------------------------

//Виртуальные методы хороши не только для использования в методах базового класса.
//Рассмотрим, что произойдет, если мы вызываем виртуальные методы через
//указатель на объект базового класса.
//Выше рассматривался такой механизм, как slicing - при копировании объекта производного
//класса в объект базового класса копируются только данные и методы базового класса.
//Пример: Пусть у нас объявлены два класса, не содержащие виртуальные функции
class Pet
{
public:
    void print() {std::cout << name << std::endl;}
    std::string name;
};
class Dog: public Pet
{
public:
    void print() {std::cout << name<<", "<<breed<<std::endl;}
    std::string breed;
};
//Создадим объект класса Dog:
void exampleOfSlicing()
{
    Dog dog;
    dog.name = "Tiny";
    dog.breed = "Dane";
    dog.print(); // Tiny, Dane

    //Теперь: что будет, если мы скопируем объект dog в объект класса Pet?
    Pet pet = dog;
    std::cout << pet.breed; //- не скомпилируется, так как при копировании объекта
    //производного класса в объект базового произошла "срезка" объекта - данные о breed потеряны.
    pet.print(); // Tiny - вызван метод базового класса из-за слайсинга.
}
//Теперь изменим класс Pet - объявим метод print виртуальным
class BetterPet
{
public:
    virtual void print() {std::cout << name << std::endl;}
    std::string name;
};
class BetterDog: public BetterPet
{
public:
    virtual void print() override {std::cout << name<<", "<<breed<<std::endl;}
    std::string breed;
};
//Опять создадим объект класса Dog, но уже по указателю:
void exampleOfPolymorphism()
{
    BetterDog *dog = new BetterDog;
    dog->name = "Tiny";
    dog->breed = "Dane";
    dog->print(); // Tiny, Dane

    //И скопируем указатель на Dog в указатель на Pet:
    BetterPet *pet = dog;
    //Хотя мы все еще не можем получить доступ к breed напрямую:
    std::cout << pet->breed; //- не скомпилируется
    //мы всё же можем получить к нему доступ через виртуальный метод print благодаря позднему связыванию:
    pet->print(); // Tiny, Dane

    delete dog;
}


//
//Еще одно применение указателей на базовые классы - это хранение объектов производных классов
//в стандартных контейнерах. Предположим, мы пишем программу для приюта домашних животных,
//и нам необходимо вести учет всех животных на содержании. Простейшая реализация этого
//учета будет представлять вектор std::vector, в который будут добавляться животные при
//поступлении в приют, и удаляться животные, покидающие приют.
//Таким образом, у нас будет нечто вроде
std::vector<BetterPet> pets;
void addPet(BetterPet pet)
{
    pet.print(); //выводим имя
    pets.push_back(pet); //запоминаем
}
//Если внимательно посмотреть на эту реализацию, то можно увидеть ряд проблем:
//1. вектор pets хранит объекты по значению, то есть мы каждый раз будем напрасно
//   копировать объекты при добавлении их в вектор.
//2. так как вектор pets хранит объекты по значению, то при добавлении любого конкретного животного
//   будет произведена срезка его объекта до базового класса, то есть вызываемый метод print()
//   будет относиться к базовому классу BetterPet.
//Этих проблем можно избежать, если хранить в векторе только указатели на объекты, приведенные к
//указателю на базовый класс:
std::vector<BetterPet*> petsPointers;
void addPet(BetterPet *pet)
{
    pet->print(); //выводим имя
    petsPointers.push_back(pet); //запоминаем
}
//1. метод addPet() теперь принимает указатель на объект базового класса, то есть копирования
//самого объекта нет.
//2. нет и срезки объекта, то есть метод print() соответствует тому производному классу,
//объект которого передан в метод. Это обеспечивается благодаря позднему связыванию.

//Подводя итоги:
//Если вы хотите получить максимум пользы от виртуальных методов:
//1. Используйте их в методах базового класса
//2. Вызывайте их через указатели на объекты базового или производного классов.


//Виртуальные методы в конструкторах и виртуальные деструкторы
//------------------------------------------------------------

//При создании объекта производного класса члены, добавленные в производный класс 
//(включая таблицу vtable) не будут созданы, пока не завершится его конструктор. 
//Поэтому если вы в конструкторе базового класса вызываете виртуальные методы, то 
//таблица vtable производного класса может еще не существовать.
//Поэтому очень плохая практика вызывать виртуальные методы в конструкторе базового класса.
//Аналогично, при уничтожении объекта производного класса сначала будут уничтожены
//добавленные члены, включая таблицу виртуальных функций, а затем уже будет вызван
//деструктор базового класса. Поэтому если вы вызовете в деструкторе базового класса
//виртуальный метод, то компилятор уже не сможет найти его объявление в таблице
//vtable производного класса.

//Следствием этого может быть нарушение логики работы программы, потеря доступа 
//к ресурсам, неосвобожденная память, даже падение программы.

//Правило, достаточное для начинающих программистов: 
//1. Никогда не вызывайте виртуальные методы в деструкторе базового класса.
//2. Если очень хочется вызвать виртуальные методы в конструкторе базового класса,
//определите невиртуальный метод, например, init(), и пропишите внутри
//вызовы виртуальных функций. Такой метод безопасно вызывать в конструкторе,
//так как его завершение не означает завершение работы конструктора. (Отложенная инициализация объекта)

//Пример: Объявим базовый и производный классы с явным вызовом виртуальных функций в конструкторе и деструкторе:
class BadPet
{
public:
    BadPet(std::string name) : name(name) {print();}
    ~BadPet() {std::cout << "Destroying BadPet "; print();}
    virtual void print() {std::cout << name << std::endl;}
    std::string name;
};
class BadDog: public BadPet
{
public:
    BadDog(std::string name, std::string breed) : BadPet(name), breed(breed)
    {print();}
    ~BadDog() {std::cout << "Destroying BadDog "; print();}
    void print() {std::cout << name<<", "<<breed<<std::endl;}
    std::string breed;
};

void exampleOfConstructionAndDestruction()
{
    BadPet *dog = new BadDog("Tiny", "Dane");
    delete dog; //вызываем деструктор.

    //После выполнения этого кода на экран будет выведено:
    //Tiny                      <- сработал конструктор базового класса
    //Tiny, Dane                <- сработал конструктор производного класса
    //Destroying BadPet Tiny    <- при попытке вызвать деструктор был вызван только деструктор базового
    //                             класса, так как компилятор вызывает декструктор для типа BadPet,
    //                             соответствующий типу указателя.
}

//Решение этой проблемы - объявить деструктор базового класса виртуальным
class VirtualPet
{
public:
    VirtualPet(std::string name) : name(name) {print();}
    virtual ~VirtualPet() {std::cout << "Destroying VirtualPet "; print();}
    virtual void print() {std::cout << name << std::endl;}
    std::string name;
};
class VirtualDog: public VirtualPet
{
public:
    VirtualDog(std::string name, std::string breed) : VirtualPet(name), breed(breed)
    {print();}
    ~VirtualDog() {std::cout << "Destroying VirtualDog "; print();}
    virtual void print() override {std::cout << name<<", "<<breed<<std::endl;}
    std::string breed;
};
void exampleOfConstructionAndDestruction1()
{
    VirtualPet *dog = new VirtualDog("Tiny", "Dane");
    delete dog; //вызываем деструктор.

    //После выполнения этого кода на экран будет выведено:
    //Tiny                              <- сработал конструктор базового класса
    //Tiny, Dane                        <- сработал конструктор производного класса
    //Destroying VirtualDog Tiny, Dane  <- сработал деструктор производного класса
    //Destroying VirtualPet Tiny        <- сработал деструктор базового класса

    //При вызове деструктора благодаря позднему связыванию был вызван правильный деструктор
    //класса VirtualDog, который в свою очередь вызвал деструктор базового класса VirtualPet.
}
//Таким образом, мы видим, что чтобы правильно удалить объект, содержащий виртуальные методы,
//необходимо объявлять его деструктор виртуальным. Достаточно объявить виртуальным деструктор
//только базового класса, так как деструкторы производных классов автоматически станут виртуальными.



//Не рассмотренные здесь вопросы:
//-------------------------------
//1. Приватное и защищенное наследование
//2. Виртуальное наследование
//3. Абстрактные классы и интерфейсы
//4. Получение информации о классе на этапе выполнения программы
//5. Удаление методов из класса
//6. Запрет наследования


//Задачи:
//Проект 1.
//---------
//Логистическая компания имеет парк грузовиков и самолетов для доставки грузов между городами.
//Компании необходимо вести учет использования каждого транспортного средства.
//Напишите базовый класс TransportVehicle, который содержит сведения о регистрационном номере
//транспортного средства, срок службы, максимальную вместимость (в кг), и вектор, содержащий
//указатели на объекты класса FreightContainer. Напишите класс FreightContainer, который
//представляет описание груза, перевозимого логистической компанией.
//Добавьте два класса, Truck и Plane, унаследованные от TransportVehicle. Класс Truck
//должен содержать расстояние, пройденное грузовиком. Класс Plane должен содержать
//время, проведенное самолетом в полете.
//Оба класса должны иметь конструкторы, задающие данные объектам классов (включая максимальную
//вместимость транспортного средства). Добавьте метод, добавляющий груз к списку грузов
//транспортного средства. Этот метод должен проверять максимальную вместимость транспортного
//средства и при превышении вместимости возвращать false.
//Напишите функцию-тест созданных классов. Функция должна содержать код для создания списка
//транспортных средств, печати регистрационных номеров и срока службы. Добавьте код,
//печатающий, сколько свободного места осталось в каждом транспортном средстве (в %).
//В конце распечатайте общую вместимость парка и процент занятого места.



//Проект 2.
//---------
//Система бронирования авиабилетов хранит информацию о проданных билетах. Напишите
//класс BasicTicket, который хранит сведения о имени пассажира, городе вылета, городе прилета,
//номере рейса и стоимости билета. Добавьте соответствующий конструктор и все методы работы со сведениями.
//Напишите производный класс PremiumTicket, который дополнительно хранит сведения
//о номере кресла пассажира. Стоимость билета PremiumTicket на 10% выше стоимости обычного
//билета.
//Напишите функцию-тест созданных классов. Она должна содержать код для создания списка
//проданных билетов разных типов, расчет общей стоимости всех билетов, расчет средней стоимости
//одного билета, расчет процентного отношения премиальных билетов
//(Подсказка: оператор dynamic_cast<> вернет nullptr, если при попытке привести указатель
//на базовый класс к указателю на производный класс объект, на который ссылается указатель,
//не является объектом производного класса)
void exampleOfDynamicCast()
{
    VirtualPet *pet = new VirtualPet("pet");
    VirtualDog *attempt1 = dynamic_cast<VirtualDog*>(pet); //attempt1 = nullptr

    VirtualPet *dog = new VirtualDog("dog", "breed");
    VirtualDog *attempt2 = dynamic_cast<VirtualDog*>(dog); //attempt2 != nullptr

    delete pet;
    delete dog;
}


//Проект 3.
//---------
//Напишите программу, имитирующую простые отношения хищник-жертва. В этой симуляции
//хищник - это тигр, жертва - олень. Они живут на поле размером 20х20 клеток.
//Только одно животное может занимать клетку. Поле ограничено, и животные не могут выйти за пределы.
//Время имитируется пошагово нажатием Enter. На кождом шагу каждое животное выполняет ряд действий.
//Тигры ходят первыми. На каждом шагу они могут:
//1. Передвинуться. Если в соседней клетке (слева, справа, сверху или снизу) есть
//олень, то тигр перемещается в эту клетку и съедает оленя.
//Если оленей в соседних клетках нет, тигр перемещается случайным образом (влево, вправо,
//вверх или вниз). Тигр не может есть других тигров.
//2. Размножиться. Если тигр выжил после 8 ходов, то он размножается, создавая нового тигра
//в случайной свободной клетке, смежной с занятой тигром. Если свободных клеток нет,
//то размножения не происходит. Тигр не может размножаться следующие 3 хода.
//3. Смерть от голода. Если тигр не съел никого за последние три хода, то он умирает.
//За тиграми ходят олени. Они могут:
//1. Передвинуться на случайную смежную незанятую клетку.
//2. Размножиться. Если олень выжил после 3 ходов, то он размножается аналогично тигру.
//Напишите графическое представление поля. Обозначьте тигров символом #, оленей символом *
//Создайте класс Organism, который содержит общие данные о оленях и тиграх.
//Добавьте в него виртуальный метод move.
//Создайте два класса Tiger и Deer, унаследованные от Organism, и переопределите метод move.
//Инициализируйте мир 5 тиграми и 100 оленями.


#endif // POLYMORPHISM_H
