#ifndef POINTERS_ARRAYS_H
#define POINTERS_ARRAYS_H

#include <string>
#include <iostream>

//Вводные данные:
//Память, которой может располагать программа при выполнении, делится на три типа.
//1. Глобальная память. Переменные, объявленные в глобальной области видимости, существуют
//всё время, пока выполняется программа. То есть они создаются при запуске программы
//и уничтожаются при ее закрытии.
//2. Стек. При запуске программе выделяется небольшая область памяти, называемая стек.
//Её состояние постоянно меняется при выполнении функций программы. При запуске любой функции
//в стек помещаются значения аргументов функции и в стеке же создаются локальные переменные.
//После завершения функции все эти переменные автоматически удаляются из стека и уничтожаются.
//Можно сказать, что стек - это "слепок" памяти программы в определенный момент её выполнения.
//3. Куча (динамическая память). Это вся свободная оперативная память компьютера,
//помимо стека и глобальной памяти программы. Если вы используете память кучи, то вы сами
//должны очищать эту память после использования.

//Указатели
//---------
void usePointers()
{
//Указатель на переменную типа T - это адрес памяти, по которому хранятся данные переменной.

    using T = int;
//Объявление:
    T* p; //указатель p на переменную типа T
    const T* p1; //указатель на константу типа T
    T* const p2 = nullptr; //константный указатель на переменную типа T

    // nullptr - это число, выражающее концепцию "нулевого указателя", то есть указателя без адреса.
    // арифметически оно равно 0, то есть вместо nullptr всегда можно использовать 0.

    //Указатель не имеет значения по умолчанию, поэтому указатель p является неинициализированным.
    //Совет: всегда инициализируйте значения своих указателей, хотя бы значением nullptr.

    //Обычный указатель: можно изменять значение данных по адресу p
    //                   можно присваивать указателю другой адрес
    //Указатель на константу: нельзя изменять данные по адресу p1,
    //                        но можно переместить указатель на другой адрес памяти
    //Константный указатель: можно менять данные, но нельзя переместить указатель p2
    const T* const p3 = nullptr; //константный указатель на константу, почти бесполезен

    //Изменение данных по адресу указателя:
    double* d1 = nullptr; //никуда не указывает, значение равно пустому указателю.
    double* d2 = 0; //то же самое, но в стиле языка С, не рекомендуется
    double* d22 = NULL; //то же самое, но в стиле Windows, не рекомендуется
    double d = 23.45;
    double* d3 = &d; //теперь указатель d3 указывает на то же место в памяти, по которому
                     //хранится переменная d (помещение в переменную d3 адреса переменной d)
    //Оператор & называется здесь оператором взятия адреса.
    //double* d4 = 42.7; //ошибка! нельзя определить адрес у числового литерала

    //Если у нас есть указатель, то получить значение, хранящееся по его адресу, можно
    //с помощью оператора разыменования *
    *d3 = -23.45; //теперь значение d тоже поменялось, так как d3 указывает на d.
    //Запомните: если указатель указывает на какой-то объект, то изменение данных по адресу
    //указателя изменит данные и у этого объекта.

    //Присвоение указателей
    d2 = d3; //теперь в d2 хранится тот же адрес, что и в d3, то есть адрес переменной d
    *d1 = *d3; //применили оператор разыменования, то есть записали по адресу d1 данные,
    //хранящиеся по адресу d3 (присвоили значение, а не адрес)

    //Адрес, на который указывает указатель, может быть и безымянным (т.е. double* d = &?)
    //Для этого используется непосредственное выделение памяти под размещение объекта
    int* i = new int; //оператором new выделили память под размещение одного целого числа
                      //и адрес памяти записали в указатель i
    //Это т.н. динамическое создание переменных (выделение памяти) в отличие от автоматического.
    //Почему динамическое:
    int i1 = 5; //переменная создается в момент, когда под нее выделяется память и
                //записывается значение 5 - автоматическое создание.
                //При выходе переменной i1 из области видимости (завершении функции) переменная
                //i1 будет уничтожена автоматически.
    int* i_p; //В момент входа в область видимости создается только указатель.
    i_p = new int; //Выделение памяти под переменную, на которую указывает i_p, физически разделено
                   //с созданием указателя
    //Таким образом, динамическое выделение памяти осуществляется только тогда, когда эта
    //память начинает использоваться. Но выделенную память необходимо освободить самостоятельно,
    //потому что при выходе из области видимости автоматически уничтожится только указатель,
    //но не выделенная память.
    delete i_p; //очистили память
    //ЗАПОМНИТЕ: При динамическом создании переменной указатель на неё будет размещён в стеке,
    //а память под переменную - выделена в куче.

    //Правила очистки памяти (правила использования delete)
    //-----------------------------------------------------
    //1. Можно удалять память, если адрес памяти корректен (если указывает на еще не удаленные данные)
    //2. Можно удалять нулевой указатель:
    int* ii = nullptr; 
    delete ii;
    //3. Запрещено очищать память, которая уже была удалена.
    int* iii = new int;
    delete iii;
    delete iii; //ошибка! Неопределенное поведение программы. Скорее всего она аварийно завершится.
    //Следствие: после удаления памяти обнулите указатель:
    int* iv = new int;
    delete iv; iv = nullptr;

    //Существует еще такая вещь, как указатель на void
    void* vP = iv;
    //Такой указатель является "универсальным", не зависящим от типа переменной, на которую указывает.
    //Он широко применяется в языке C, но в C++ лучше его избегать. Чтобы получить из него
    //адрес переменной конкретного типа, его необходимо привести к нужному виду:
    int* iP = static_cast<int*>(vP);
    *iP = 90;
    //Указатель на void можно встретить в возвращаемом функцией значении, если функция должна возвращать
    //указатели на объекты самых разных классов/типов:
}
void* getSomeObject(int type)
{
    switch(type) {
        case 0: return new int;
        case 1: return new double;
        case 2: return new std::string;
            //и т.д.
        default: break;
    }
    return nullptr;
}

//Передача указателей в функцию и возвращение из функции
//------------------------------------------------------

//Так как указатель - это просто адрес памяти, то вместо передачи реальных переменных
//в функцию можно передавать адреса этих переменных. Такая передача называется call-by-pointer
//и является альтернативой передаче по ссылке.

void callByPointer(double* d1, double* d2)
{
    double temp = *d1;
    *d1 = *d2;
    *d2 = temp;
}
//то же самое, но с передачей по ссылке, читается легче:
void callByReference(double& d1, double& d2)
{
    double temp = d1;
    d1 = d2;
    d2 = temp;
}
//При использовании аргументов, передаваемых по указателю, необходимо следить, чтобы
//эти указатели не указывали на невалидную память, иначе при их разыменовании программа
//попытается прочитать невалидный адрес в памяти, и упадет. Элементарная проверка
//выполняется следующим образом:
bool checkForPositive(double *var)
{
    if (var) //проверяем указатель на валидность
        return (*var>0); //разыменовываем указатель
    return false;
}


//Обычно в программах C++ используют передачу по ссылке, так как ссылки обладают
//рядом преимуществ перед указателями:
//1. Ссылка не может быть неинициализированной - она всегда ссылается на реально
//   существующую переменную.
//2. Указатель же может быть обнулен, случайно или намеренно, или может быть не инициализирован.

//Но и у указателей есть преимущество:
//1. Если передаваемый аргумент необязательно должен быть проинициализирован, то можно передать
//нулевой указатель, и проверять указатель на валидность в самой функции:
std::string append(std::string s1, std::string s2, int *newLength=nullptr)
{
    //в этой функции мы получаем длину новой строки, но только если пользователь этого хочет
    s1.append(s2);
    if (newLength) *newLength = s1.length();
    return s1;
}
//Использование:
void useAppend()
{
    std::string s1 = "a";
    std::string s2 = "bcde";
    int len; //буфер под длину строки
    std::cout << append(s1, s2, &len); //передаем в функцию адрес переменной len
    std::cout << " " << len; //выведет 5

    std::cout << append(s2, s1); //нас не интересует длина, поэтому передаем нулевой указатель
}

//Возвращение указателя из функции имеет смысл только в двух случаях:
//1. Возвращение переданного в функцию указателя
//2. Возвращение указателя на динамически выделенную память
//Возвращение указателя на автоматически созданную в функции переменную не имеет смысла,
//так как переменная будет уничтожена после выхода из функции, и указатель станет невалидным.

//Примеры:
double* increaseAndReturn(double* d, double delta)
{
    *d += delta;
    return d;
}
//Использование: double d = 10; double *d1 = increaseAndReturn(&d, 2); //d = 12, *d1=12

double* createAndReturn(int seed)
{
    double* d = new double;
    *d = 1.123 * ((seed % 11) + (seed % 13) + (seed % 7));
    return d;
}
//Использование: double* d1 = createAndReturn(1000); ... delete d1;
//Не забываем, что функция createAndReturn динамически выделяет память, но не освобождает ее.
//Делаем это самостоятельно.

double* wrongUse(int seed)
{
    double d = 1.123 * ((seed % 11) + (seed % 13) + (seed % 7));
    return &d; //попытка вернуть адрес локальной переменной d, которая будет уничтожена при
    //выходе из функции. Указатель станет невалидным.
}

//Задания:
//=================

//1. Что будет выведено при выполнении следующего кода?
int *p1, *p2;
p1 = new int;
p2 = new int;
*p1 = 10;
*p2 = 20;
cout << *p1 << " " << *p2 << endl;
p1 = p2;
cout << *p1 << " " << *p2 << endl;
*p1 = 30;
cout << *p1 << " " << *p2 << endl;
//Как изменится вывод, если заменить
*p1 = 30;
//на следующее?
*p2 = 30;

//2.  Что будет выведено при выполнении следующего кода?
int *p1, *p2;
p1 = new int;
p2 = new int;
*p1 = 10;
*p2 = 20;
cout << *p1 << " " << *p2 << endl;
*p1 = *p2;
cout << *p1 << " " << *p2 << endl;
*p1 = 30;
cout << *p1 << " " << *p2 << endl;

//3. Перепишите следующую функцию таким образом, чтобы она принимала указатели, а не ссылки:
int swapAndReturnMax(int &first, int& second)
{
    int temp = first;
    first = second;
    second = temp;
    if (first > second) return first;
    return second;
}

//4. Перепишите следующую функцию таким образом, чтобы она принимала ссылки, а не указатели:
//(эта функция вычисляет значения корней квадратного уравнения)
int roots(double a, double b, double c, double *x1, double *x2)
{
    if (a==0) {
        if (b==0) {
            if (c==0) {
                return INT_MAX; //бесконечно много корней
            }
            else {
                return 0; //нет корней
            }
        }
        else {
            if (x1!=nullptr) *x1 = -c/b;
            return 1; //один корень
        }
    }
    else {
        double D = b*b-4*a*c;
        if (D<0) {
            return 0; //нет корней
        }
        else if (D==0) {
            if (x1) *x1 = -b/2/a;
            if (x2) *x2 = -b/2/a;
            return 2; //два корня
        }
        else {
            if (x1) *x1 = (-b-sqrt(D))/2/a;
            if (x2) *x2 = (-b+sqrt(D))/2/a;
            return 2;
        }
    }
}

//Указатели на функции
//--------------------

//Вы можете сохранить в указателе адрес функции, и передать потом этот указатель в другую функцию,
//вызывая сохраненную функцию.

//Предположим, у вас есть объявленная функция, возвращающая статус чего-либо:
int getStatus()
{
    return 0;
}

//вы можете получить адрес этой функции в памяти:
void useFunctionPointers()
{
    int (*fn)() = getStatus;
    if (fn() > 0) {//а затем вызвать функцию по указателю
        //код
    }
}
//Вызов функции по указателю - это использование имени указателя вместо имени функции.

//Указатель на функцию, которая принимает два аргумента и возвращает число:
double calculate(double first, double second) {return 0;}
double (*calP)(double, double) = calculate; //в указателе calP - адрес функции calculate
//Указатель на функцию, которая ничего не возвращает:
void doSmth() {}
void (*doSmthP)() = doSmth;

//Практический пример: калькулятор. Напишем функцию, которая принимает два числа и указатель на
//функцию, производящую расчеты с этими числами. В функцию будем передавать разные арифметические функции:
double getSum(double first, double second) {return first+second;}
double getDifference(double first, double second) {return first-second;}
double getProduct(double first, double second) {return first*second;}
double getQuotient(double first, double second) {return first/second;}
//Все эти функции имеют одинаковую сигнатуру, то есть одинаковый "тип". Объявим новый тип, соответствующий
//сигнатуре этих операций:
using Func = double (*)(double,double);
//или typedef double (*Func)(double, double);
//теперь мы можем создавать сколько угодно указателей этого типа:
Func f1 = getSum;
Func f2 = getProduct;
//и т.д.
//Напишем простейший калькулятор:
double calculator(double x, double y, Func fn)
{
    return fn(x, y);
}
//Теперь мы можем передавать в функцию calculator любые операции:
char operation;
cin >> operation >> x >> y; //+ 5 6
switch (operation) {
    case '+': cout << calculator(x,y,operations[operator]); break;
}
double res1 = calculator(1,2,getSum); //равно 3
double res2 = calculator(1,2,getDifference);//равно -1
double res3 = calculator(1,2,getProduct);//равно 2

//Указатели на функции обычно используются там, где необходимо обобщить некоторые операции (как в случае калькулятора),
//или передать в функцию некоторое действие, заранее неизвестное, которое будет выполняться регулярно:
using callback = void(*)(const std::string &);
void longOperation(int n, const callback progress)
{
    for (int i=0; i<n; ++i) {
        //do something
        std::string message {"iteration "};
        message.append(std::to_string(i));
        progress(message); //вызываем обработчик сообщения
    }
}
//Теперь мы можем создать наш обработчик сообщений, например, просто выводить сообщение в консоль:
void toCout(const std::string &message)
{
    std::cout << message << std::endl;
}
//И выполнить нашу длинную операцию:
void doSomethingLong()
{
    longOperation(1000, toCout);
}
//Заметьте: сигнатура передаваемой функции должна совпадать с сигнатурой указателя на функцию.


#endif // POINTERS_ARRAYS_H
