#ifndef SORTING_H
#define SORTING_H

#include <vector>
#include <functional>
#include <iostream>

void printVec(std::vector<int> &vec)
{
    for (int i:vec) std::cout << i << " ";
    std::cout << std::endl;
}

//Под сортировкой массива понимают упорядочивание его элементов, обычно по возрастанию.
//В качестве элементов массива могут выступать элементы любых типов, для которых имеет
//смысл упорядочивание по любому критерию.

//Алгоритмы сортировки могут иметь разную сложность. Наиболее простые алгоритмы выполняются за O(N^2)
//(сортировка вставкой, пузырьковая сортировка). Эффективный алгоритм сортировки Шелла имеет
//сложность o(N^2) (т.е. в худшем случае он выполняется за N^2 времени.
//Оптимизированные алгоритмы сортировки имеют сложность O(N logN). В общем случае любой алгоритм
//имеет сложность Ω(N logN).

//Терминология: Считаем, что для типа элементов вектора определены операторы < и >.
//Количество элементов в векторе равно N.

//Будем давать две реализации алгоритмов: первая - для сортировки передаваемого vector,
//вторая - обобщенная, с использованием итераторов по контейнеру и объекта-компаратора.

/**
  * ПУЗЫРЬКОВАЯ СОРТИРОВКА - BUBBLE SORT
  */

//Это простейший вид сортировки, имеет квадратичное время выполнения в лучшем случае,
//то есть его сложность равна O(N^2).
//Этот вид сортировки состоит в N-1 проходах по контейнеру.
//Во время прохода p=0..N-2 мы проходим по контейнеру и попарно сравниваем элементы j=0..N-2-p.
//Если левый элемент больше правого, то меняем их местами. Таким образом, максимальный элемент
//оказывается на своей позиции в правой части контейнера - как бы "всплывает" на свое место как пузырек.

/*Исходный массив
           34  8   64  51  32  21  поменяны местами элементы
p=0, j=0   8   34  64  51  32  21    0 и 1
p=0, j=1   8   34  64  51  32  21    никакие
p=0, j=2   8   34  51  64  32  21    2 и 3
p=0, j=3   8   34  51  32  64  21    3 и 4
p=0, j=4   8   34  51  32  21  64    4 и 5, элемент 64 на своем месте

p=1, j=0   8   34  51  32  21  _64_  никакие
p=1, j=1   8   34  51  32  21  _64_  никакие
p=1, j=2   8   34  32  51  21  _64_  2 и 3
p=1, j=3   8   34  32  21  51  _64_  3 и 4, элемент 51 на своем месте

p=2, j=0   8   34  32  21  _51_ _64_ никакие
p=2, j=1   8   32  34  21  _51_ _64_ 1 и 2
p=2, j=2   8   32  21  34  _51_ _64_ 2 и 3, элемент 34 на своем месте

p=3, j=0   8   32  21  _34_ _51_ _64_ никакие
p=3, j=1   8   21  32  _34_ _51_ _64_  1 и 2, элемент 32 на своем месте

p=4, j=0   8   21  _32_ _34_ _51_ _64_ никакие, элемент 21 на своем месте
*/


template <typename Comparable>
void bubbleSort(std::vector<Comparable> &a)
{
    for (int p=0; p<a.size()-1; ++p) {
        for (int j=0; j < a.size()-1-p; ++j)
            if (a[j+1]<a[j]) std::swap(a[j], a[j+1]);
    }
}

//Вариант с тремя аргументами
template<typename Iterator, typename Comparator>
void bubbleSort(const Iterator& begin, const Iterator& end, Comparator lessThan)
{
    if (begin==end) return;
    Iterator j;
    for (Iterator p=begin; p!=end-1; ++p) {
        for (j=begin; j!=end-1-p; ++j)
            if (lessThan(*j, *(j+1)))
                std::swap(*j, *(j+1));
    }
}

//Вариант с двумя аргументами - по умолчанию сортировка по возрастанию
template<typename Iterator>
void bubbleSort(const Iterator &begin, const Iterator &end)
{
    bubbleSort(begin, end, std::less<decltype(*begin)>{});
}

//Сложность алгоритма: Внутренний цикл выполняется сначала N-1 раз, потом N-2 раз, и так далее до 1.
//Суммируя, получаем: Σi = N-1 + N-2 + N-3 + ... + 1 = N(N-1)/2 = 0.5N^2 - 0.5N, то есть квадратичное
//время. Это оценка и снизу, и сверху - алгоритм не может выполняться быстрее, то есть
//оценка сложности равна Θ(N^2). При оценке верхней границы в этом случае можно просто написать,
//что алгоритм работает не выстрее, чем O(N^2).

/**
  ПУЗЫРЬКОВАЯ СОРТИРОВКА - МОДИФИЦИРОВАННЫЙ АЛГОРИТМ
  */

//Этот алгоритм использует тот факт, что если за один проход внутреннего цикла не было
//совершено ни одного обмена, то "несортированная" часть контейнера уже отсортирована,
//и можно прервать алгоритм.

template <typename Comparable>
void bubbleSort_revised(std::vector<Comparable> &a)
{
    bool done = false;
    for (int p=0; p<a.size()-1 && !done; ++p) {
        done = true;
        for (int j=0; j < a.size()-1-p; ++j)
            if (a[j+1]<a[j]) {
                std::swap(a[j], a[j+1]);
                done = false;
            }
    }
}

//Вариант с тремя аргументами
template<typename Iterator, typename Comparator>
void bubbleSort_revised(const Iterator& begin, const Iterator& end, Comparator lessThan)
{
    if (begin==end) return;
    bool done = false;
    for (Iterator p=begin; p!=end-1 && !done; ++p) {
        done = true;
        for (Iterator j=begin; j!=end-1-p; ++j)
            if (lessThan(*j, *(j+1))) {
                std::swap(*j, *(j+1));
                done = false;
            }
    }
}

//Вариант с двумя аргументами - по умолчанию сортировка по возрастанию
template<typename Iterator>
void bubbleSort_revised(const Iterator &begin, const Iterator &end)
{
    bubbleSort_revised(begin, end, std::less<decltype(*begin)>{});
}

//Средняя сложность алгоритма от этого не меняется - в худшем случае алгоритм имеет квадратичную сложность,
//в лучшем случае - линейную.

/**
  СОРТИРОВКА ВЫБОРОМ - SELECTION SORT
  */

//Этот вид сортировки имеет квадратичную сложность: За N-1 проходов неотсортированной части
//контейнера среди элементов находится позиция минимального элемента. Затем минимальный элемент
//помещается в конец отсортированной части контейнера.

/*Исходный массив   34  8   64  51  32  21
                                     индекс минимального элемента
p=0   34    8     64    51  32  21      1, обмениваем 0 и 1
p=1   _8_   34    64    51  32  21      5, обмениваем 1 и 5
p=2   _8_  _21_   51    64  32  34      4, обмениваем 2 и 4
p=3   _8_  _21_  _32_   64  51  34      5, обмениваем 3 и 5
p=4   _8_  _21_  _32_  _34_ 51  64      4, ничего не обмениваем
*/

template <typename Comparable>
void selectionSort(std::vector<Comparable> &a)
{
    for (int p=0; p<a.size()-1; ++p) {
        int min = p;
        for (int j=p+1; j < a.size(); ++j)
            if (a[j]<a[min]) min = j;
        std::swap(a[p], a[min]);
    }
}

//Вариант с тремя аргументами
template<typename Iterator, typename Comparator>
void selectionSort(const Iterator& begin, const Iterator& end, Comparator lessThan)
{
    if (begin==end) return;
    Iterator j;
    for( Iterator p = begin; p != end-1; ++p )
    {
        auto min = std::move( *p );
        for( j = p+1; j != end; ++j ) {
            if (lessThan(*j, *min))
                min = std::move(*j);
        }
        std::swap(*p, *min);
    }
}

//Вариант с двумя аргументами - по умолчанию сортировка по возрастанию
template<typename Iterator>
void selectionSort(const Iterator &begin, const Iterator &end)
{
    selectionSort(begin, end, std::less<decltype(*begin)>{});
}

//Сложность алгоритма - квадратичная: за первую итерацию внешнего цикла внутренний цикл выполнит N-1 операций,
//затем N-2, N-3 ... 1.
//Суммируя, получаем: Σi = N-1 + N-2 + N-3 + ... + 1 = N(N-1)/2 = 0.5N^2 - 0.5N, то есть квадратичное время.

/**
  * СОРТИРОВКА ВСТАВКОЙ - INSERTION SORT
  */
//Этот вид сортировки состоит в N-1 проходах по контейнеру. Для прохода p=1..N-1
//элементы контейнера 0..p-1 уже отсортированы.
//Во время прохода p мы перемещаем элемент в позиции p влево, пока он не встанет в правильное место
//среди первых p+1 элементов.
//Описание алгоритма: 1. Запоминаем элемент в позиции p.
//2. Все элементы, большие запомненного, находящиеся слева от него, перемещаются на одну
//позицию вправо.
//3. Записываем элемент из позиции p в новую позицию.

/*Исходный массив
            34  8   64  51  32  21  сдвинуто элементов
После p=1   8   34  64  51  32  21   1
После p=2   8   34  64  51  32  21   0
После p=3   8   34  51  64  32  21   1
После p=4   8   32  34  51  64  21   3
После p=5   8   21  32  34  51  64   4
*/

template <typename Comparable>
void insertionSort(std::vector<Comparable> &a)
{
    for (int p=1; p<a.size(); ++p) {
        Comparable tmp = std::move(a[p]);

        int j;
        for (j=p; j>0 && tmp < a[j-1]; --j)
            a[j]=std::move(a[j-1]);
        a[j] = std::move(tmp);
    }
}

//Вариант с тремя аргументами
template<typename Iterator, typename Comparator>
void insertionSort(const Iterator& begin, const Iterator& end, Comparator lessThan)
{
    if (begin==end) return;
    Iterator j;
    for (Iterator p=begin+1; p!=end; ++p) {
        auto tmp = std::move(*p);
        for (j=p; j!=begin && lessThan(tmp, *(j-1)); --j)
            *j = std::move(*(j-1));
        *j = std::move(tmp);
    }
}

//Вариант с двумя аргументами - по умолчанию сортировка по возрастанию
template<typename Iterator>
void insertionSort(const Iterator &begin, const Iterator &end)
{
    insertionSort(begin, end, std::less<decltype(*begin)>{});
}

//Из-за вложенных циклов, каждый из которых может иметь N итераций, сложность сортировки вставкой
//равна O(N^2). Действительно: каждый внутренний цикл имеет максимум p+1 итераций для
//каждого значения p от 1 до N-1. Таким образом, суммируя количество итераций по внешнему циклу, получаем
// Σi = 2+3+4+...+N =  Θ(N^2). С другой стороны, если контейнер частично отсортирован, то внутренний цикл
//не выполняется, и сложность алгоритма в этом случае равна O(N). В худшем случае получаем оценку O(N^2).

/**
  * СОРТИРОВКА ШЕЛЛА - SHELL SORT
  * */

//Названа по имени изобретателя, Дональда Шелла. Имеет субквадратическую сложность за счет того,
//что сравниваются элементы, находящиеся далеко друг от друга.
//Алгоритм сортировки Шелла похож на алгоритм пузырьковой сортировки: мы попарно обмениваем элементы.
//Однако сравниваем мы не соседние элементы, а элементы, расположенные на расстоянии h друг от друга.
//С каждым проходом контейнера размер промежутка между сравниваемыми элементами уменьшается.

//После прохода i с промежутком h_i элементы на расстоянии h_i друг от друга становятся отсортированы.

template<typename Comparable>
void shellSort(std::vector<Comparable> &a)
{
    //на каждом проходе контейнера уменьшаем размер h вдвое
    //в начале работы алгоритма h = N/2
    for (int gap = a.size()/2; gap>0; gap/=2) {
        for (int i=gap; i<a.size(); ++i) {
            Comparable tmp = std::move(a[i]);
            int j=i;
            for (; j>=gap && tmp < a[j-gap]; j-=gap)
                a[j] = std::move(a[j-gap]);
            a[j] = std::move(tmp);
        }
    }
}

//реализация через swap
template<typename Comparable>
void shellSort1(std::vector<Comparable> &a)
{
    //на каждом проходе контейнера уменьшаем размер h вдвое
    for (int gap = a.size()/2; gap>0; gap/=2) {
        for (int i=gap; i<a.size(); ++i) {
            for (int j = i-gap; j>=0 && a[j]>a[j+gap]; j-=gap)
                std::swap(a[j], a[j+gap]);
        }
    }
}

//Сложность сортировки Шелла рассчитать сложно. В худшем случае алгоритм работает как Θ(N^2).
//При удачном выборе значений h_i сложность алгоритма понижается до O(N^3/2), то есть до субквадратичной.

/**
  СОРТИРОВКА КУЧЕЙ - HEAP SORT
  */

//Сортировка кучей использует тот факт, что поиск наименьшего/наибольшего элемента в такой структуре данных,
//как бинарная куча (heap), требует не более O(logN) операций. Создание кучи требует 2N операций.
//из кучи извлекается N элементов, то есть при сортировке выполняется не больше 2N+N*logN операций,
//то есть сложность алгоритма равна O(N logN).

//Алгоритм:
//1. Создать кучу из исходного контейнера.
//2. Извлечь максимальные элементы из кучи по одному, помещая их в конец контейнера

//Internal method for heapsort.
//Возвращает индекс левого потомка.
inline int leftChild(int i)
{
    return 2*i+1;
}

//Внутренний метод для heapsort, который используется для построения кучи и удаления максимального элемента
//i - позиция, от которой начинаем percolate ().
//n - логический размер бинарной кучи
template <typename Comparable>
void percolateDown(std::vector<Comparable> & a, int i, int n)
{
    int child;
    Comparable tmp;

    for (tmp = std::move(a[i]); leftChild(i) < n; i = child) {
        child = leftChild(i);
        if (child != n-1 && a[child] < a[child+1])
            ++child;
        if(tmp < a[child])
            a[i]=std::move(a[child]);
        else
            break;
    }
    a[i]=std::move(tmp);
}

//Алгоритм сортировки кучей
template <typename Comparable>
void heapsort(std::vector<Comparable> & a)
{
    for (int i = a.size()/2-1; i>=0; --i) //строим кучу
        percolateDown(a, i, a.size());
    for (int j = a.size() - 1; j > 0; --j) {
        std::swap(a[0], a[j]); //удаляем максимальный элемент из кучи
        percolateDown(a, 0, j);
    }
}

/**
  СОРТИРОВКА СЛИЯНИЕМ - MERGE SORT
  */

//Сортировка слиянием представляет собой рекурсивный алгоритм. В его основе - слияние двух
//уже отсортированных контейнеров. Так как эти контейнеры уже отсортированы, то сделать это можно
//за линейное время.

//Пусть A и B - два отсортированных списка, C - результирующий список. Алгоритм такой:
//1. Сначала указатели стоят на началах списков A и B. Помещаем в список С наименьший из двух
//элементов A0 или B0.
//2. Передвигаем указатель вправо на один элемент в том списке, из которого взяли
//наименьший элемент.
//Повторяем операции 1-2, пока не исчерпаем любой из списков A или B.
//3. Помещаем в список C остаток еще не исчерпанного списка.

//Пример:
//А = _1 13 24 26
//В = _2 15 27 38

//Первый шаг: С = 1 _ _ _ _ _ _ _
//А = 1 _13 24 26
//В = _2 15 27 38

//Второй шаг: С = 1 2 _ _ _ _ _ _
//А = 1 _13 24 26
//В = 2 _15 27 38

//Третий шаг: С = 1 2 13 _ _ _ _ _
//А = 1 13 _24 26
//В = 2 _15 27 38

//Четвертый шаг: С = 1 2 13 15 _ _ _ _
//А = 1 13 _24 26
//В = 2 15 _27 38

//Пятый шаг: С = 1 2 13 15 24 _ _ _
//А = 1 13 24 _26
//В = 2 15 _27 38

//Шестой шаг: С = 1 2 13 15 24 26 _ _
//А = 1 13 24 26 (исчерпали)
//В = 2 15 _27 38

//Остаток списка В помещаем в С: 1 2 13 15 24 26 27 38

//Сложность алгоритма - не хуже, чем NlogN.

//Алгоритм сортировки слиянием:
//1. Разделить контейнер на два списка.
//2. Рекурсивно отсортировать оба списка.
//3. Слить оба отсортированных списка в общий.


//Внутренний метод, который сливает две отсортированные половины вектора.
//a - это вектор элементов с сортированными половинами.
//tmpArray - это вектор, куда помещаем объединенные половины.
//leftPos - это левый индекс подмассива.
//rightPos - это индекс, с которого начинается правый подмассив.
//rightEnd - это правый индекс подмассива.
template <typename Comparable>
void merge(std::vector<Comparable> & a, std::vector<Comparable> & tmpArray,
           int leftPos, int rightPos, int rightEnd )
{
    int leftEnd = rightPos - 1;
    int tmpPos = leftPos;
    int numElements = rightEnd - leftPos + 1;

    while (leftPos <= leftEnd && rightPos <= rightEnd )
        if( a[ leftPos ] <= a[ rightPos ] )
            tmpArray[tmpPos++] = std::move(a[leftPos++]);
        else
            tmpArray[tmpPos++] = std::move(a[rightPos++]);

    while(leftPos <= leftEnd) // копируем остаток первой половины
        tmpArray[tmpPos++] = std::move(a[leftPos++]);

    while(rightPos <= rightEnd) // копируем остаток правой половины
        tmpArray[tmpPos++] = std::move(a[rightPos++]);

    // копируем tmpArray обратно
    for(int i = 0; i < numElements; ++i, --rightEnd)
        a[rightEnd] = std::move(tmpArray[rightEnd]);
}

//Рекурсивная функция.
//a - сортируемый вектор.
//tmpArray - временный вектор, куда помещаем отсортированные результаты.
//left - левый индекс подмассива.
//right - правый индекс подмассива.
template <typename Comparable>
void mergeSort(std::vector<Comparable> & a,
                std::vector<Comparable> & tmpArray, int left, int right)
{
    if (left < right) {
        int center = (left + right) / 2;
        mergeSort(a, tmpArray, left, center);
        mergeSort(a, tmpArray, center + 1, right);
        merge(a, tmpArray, left, center + 1, right);
    }
}

template <typename Comparable>
void mergeSort(std::vector<Comparable> & a)
{
    std::vector<Comparable> tempArray(a.size());
    mergeSort(a, tempArray, 0, a.size()-1);
}

/**
  БЫСТРАЯ СОРТИРОВКА - QUICK SORT
  */

//Быстрая сортировка - это еще одна рекурсивная сортировка, очень простая по своей структуре.
//Суть алгоритма: выбираем какой-то ключевой элемент из контейнера, и считаем, что он стоит на своем месте.
//Рекурсивно сортируем элементы меньшие чем ключевой элемент и элементы большие чем ключевой.

//Выбор ключевого элемента влияет на максимальную сложность алгоритма. В худшем случае
//алгоритм становится квадратичным. В лучшем случае сложность не превышает N logN.

//Описание начнем с простого примера:
//1. Выберем произвольное число pivot.
//2. Разобьем исходный контейнер на три контейнера:
//- контейнер smaller, содержащий элементы, меньшие чем pivot
//- контейнер same, содержащий элементы, равные pivot
//- контейнер larger, содержащий элементы, большие чем pivot.
//3. Рекурсивно отсортируем контейнеры smaller и larger.
//4. Соединим контейнеры последовательно: smaller+same+larger.

template<typename Comparable>
void quickSortStub(std::vector<Comparable> &items)
{
    if (items.size()>1) {
        std::vector<Comparable> smaller;
        std::vector<Comparable> same;
        std::vector<Comparable> larger;

        //в качестве pivot возьмем элемент в середине контейнера
        auto pivot = items[items.size()/2];

        for (auto& i: items) {
            if (i<pivot) smaller.push_back(std::move(i));
            else if (i==pivot) same.push_back(std::move(i));
            else larger.push_back(std::move(i));
        }

        //рекурсивно сортируем два контейнера
        quickSortStub(smaller);
        quickSortStub(larger);

        //копируем всё в исходный контейнер
        std::move(begin(smaller), end(smaller), begin(items));
        std::move(begin(same), end(same), begin(items)+smaller.size());
        std::move(begin(larger), end(larger), end(items)-larger.size());
    }
}

//Такой алгоритм: во-первых, на каждом шаге требует выделения дополнительной памяти для трех контейнеров,
//во-вторых, не быстрее, чем сортировка слиянием. Кроме того, в качестве ключевого
//мы использовали элемент из середины контейнера, но в зависимости от его величины
//в один из векторов smaller и larger может попасть очень мало элементов, что значительно
//ухудшит производительность алгоритма. Поэтому обычно используют модифицированную
//версию quicksort, которая потребляет меньше памяти и в худшем случае имеет сложность O(N logN).

//Модифицированная версия:
//1. Если количество элементов в S равно 0 или 1, завершаем работу.
//2. Выбираем произвольный элемент pivot в S.
//3. Делим множество S\{pivot} на два множества:
//   S1 = {x | x<=pivot}
//   S2 = {x | x>=pivot}
//4. Возвращаем quicksort(S1)+{pivot}+quicksort(S2)

//Выбор значения pivot:
//Если в качестве pivot мы возьмем первый элемент контейнера (или второй, или средний),
//то может получиться так (если контейнер уже частично отсортирован), что в S1 или в S2
//попадут все элементы контейнера. Это значительно замедлит работу алгоритма
//(вплоть до квадратичного времени выполнения).
//Гораздо безопаснее выбирать случайный элемент контейнера. Однако использование
//генератора случайных чисел также сильно замедлит алгоритм. Поэтому чаще всего
//используют следующую стратегию:
//1. Берут левый, средний и правый элемент контейнера.
//2. pivot = медианному из них (который не больше самого маленького и не меньше самого большого).
//Например, для контейнера S=(8,1,4,9,6,3,5,2,7,0) left=8, center=6, right=0, из них
//только средний не больше 0 и не меньше 8. То есть pivot = 6.

//Стратегия разбиения контейнера
//Для уменьшения объема потребляемой памяти принято
//не создавать два отдельных контейнера S1 и S2, а перемещать элементы непосредственно в
//исходном контейнере. Алгоритм здесь следующий:

//1. Переместим ключевой элемент в конец контейнера, чтобы он не мешался:
//   S = (8,1,4,9,0,3,5,2,7,6)
//2. Поместим указатели i и j на первый и последний (без pivot) элементы контейнера:
//       (8,1,4,9,0,3,5,2,7,6)
//        ↑               ↑
//        i               j
//3. Перемещаем элементы, меньшие pivot, в левую часть контейнера, большие pivot - в правую.
//Для этого:
//- пока i<j смещаем i вправо, пропуская элементы, меньшие чем pivot. Смещаем j влево,
//пропуская элементы, большие чем pivot. Останавливаемся, когда i указывает на элемент > pivot,
//а j указывает на элемент < pivot.
//- обмениваем местами элементы в позициях i и j.
//- повторяем эти операции, пока i не станет равно j.
//4. Обмениваем местами элемент pivot с элементом в позиции i.

//Первый сдвиг: (8,1,4,9,0,3,5,2,7,6)
//               ↑             ↑
//               i             j
//После первого обмена: (2,1,4,9,0,3,5,8,7,6)
//                       ↑             ↑
//                       i             j
//Второй сдвиг: (2,1,4,9,0,3,5,8,7,6)
//                     ↑     ↑
//                     i     j
//После второго обмена: (2,1,4,5,0,3,9,8,7,6)
//                             ↑     ↑
//                             i     j
//Третий сдвиг: (2,1,4,5,0,3,9,8,7,6)
//                           ↑
//                          i j
//Обмениваем i и pivot: (2,1,4,5,0,3,6,8,7,9)
//                                   ↑
//                                  i j

//Если в контейнере встречаются элементы, равные pivot, то хорошей стратегией будет
//обменивать такие элементы по описанному алгоритму, так как в противном случае мы можем
//значительно ухудшить скорость алгоритма (доказательство этого выпускаем).

//Последнее замечание: быстрая сортировка работает не очень хорошо на небольших контейнерах
//(N<=20), так как много времени тратится на реорганизацию контейнера и рекурсивные вызовы.
//В таких случаях используют алгоритмы, оптимизированные для небольших контейнеров,
//например сортировку вставкой.

//Реализация алгоритма quicksort с учетом всех замечаний:

template<typename Comparable>
void quickSort(std::vector<Comparable> &a)
{
    quickSort(a, 0, a.size()-1);
}

//Функция, возвращающая элемент pivot.
//Элементы left, center и right сразу перемещаются в правильные части контейнера,
//что ускоряет алгоритм.
//left и right - это границы рассматриваемого интервала
template <typename Comparable>
const Comparable &median3(std::vector<Comparable> &a, int left, int right)
{
    int center = (left+right)/2;

    if (a[center] < a[left]) std::swap(a[left], a[center]);
    if (a[right] < a[left]) std::swap(a[left], a[right]);
    if (a[right] < a[center]) std::swap(a[right], a[center]);
    //теперь pivot гарантированно находится в center

    //перемещаем pivot в позицию right-1
    std::swap(a[center], a[right-1]);

    return a[right-1];
}

//Внутренняя рекурсивная функция
template<typename Comparable>
void quickSort(std::vector<Comparable> &a, int left, int right)
{
    if (left+10 <= right) {
        const Comparable& pivot = median3(a, left, right);

        //начинаем разделять элементы
        int i=left;
        int j=right-1;
        for (;;) {
            while(a[++i]<pivot) {}
            while(a[--j]>pivot) {}
            if (i<j)
                std::swap(a[i], a[j]);
            else
                break;
        }

        std::swap(a[i], a[right-1]); //восстанавливаем pivot на своем месте

        quickSort(a, left, i-1); //сортируем левую часть
        quickSort(a, i+1, right); //сортируем правую часть
    }
    else {
    //Если размер контейнера не превышает 10, то быстрее будет использовать сортировку вставкой
        insertionSort(a, left, right);
    }
}

/**
  СОРТИРОВКИ ЗА ЛИНЕЙНОЕ ВРЕМЯ
  */

//Если при сортировке контейнера ключевым является время выполнения, а объем памяти
//не ограничен, то удобнее использовать алгоритмы сортировки, гарантированно выполняющиеся
//за линейное время.

//Рассмотрим следующий упрощенный пример. Пусть требуется отсортировать последовательность
//из целых положительных чисел, не превышающих M: A1, A2, A3... An<=M
//Создадим вспомогательный вектор count длиной M, который изначально пуст.
//Будем считывать элементы последовательности по одному: A1, A2, A3... При считывании Ai
//увеличим count[Ai] на 1. В итоге в векторе count у нас будет записана частота встречаемости
//каждого элемента A1, A2...An.
//Этот алгоритм, называемый также bucket sort, равносилен раскладыванию объектов
//по корзинам в зависимости от их типа.
//В конце нам достаточно извлечь количество определенных элементов и продублировать их в
//исходной последовательности:
//A1  A1  A1  A2  A2  A3 ... Ai Ai Ai
//3 раза      2 раза  1 раз  3 раза

//Сложность алгоритма равна O(M+N), где M - максимально возможное значение элементов,
//                                      N - количество элементов последовательности.

//Этот алгоритм пригоден и для сортировки последовательности по мере ее поступления на вход
//алгоритма, то есть когда размер последовательности заранее неизвестен.

//Очевидный недостаток bucket sort - размер вектора count, если диапазон значений элементов велик.
//Чтобы уменьшить вектор count, мы можем создавать "ведра" не под каждое значение элемента,
//а только под остаток от деления элемента на некоторое число (обычно 10). Такая сортировка
//называется radix sort. Рассмотрим следующий пример:

//Пусть требуется отсортировать 10 чисел в диапазоне 0-999. Прямое использование bucket sort
//потребует создать вектор count длиной 1000, в котором будет не больше 10 занятых ячеек.
//Вместо этого создадим вектор count длиной 10, в который будем помещать элементы по цифре единиц,
//затем по цифре десятков, затем по цифре сотен. Можно показать, что последовательные прохождения
//массива не портят предыдущую сортировку, то есть после трех прохождений массива мы получим
//полностью отсортированный массив.

//Начальный вектор:                  064 008 216 512 027 729 000 001 343 125
//После сортировки по правой цифре:  000 001 512 343 064 125 216 027 008 729
//После сортировки по средней цифре: 000 001 008 512 216 125 027 729 343 064
//После сортировки по левой цифре:   000 001 008 027 064 125 216 343 512 729

//Сортировку radix sort часто применяют для сортировки строк ASCII одинаковой длины,
//в которых каждый символ принадлежит диапазону ASCII, то есть код символа не превышает 256.

void radixSort(std::vector<std::string> & a, int stringLength)
{
    std::vector<std::vector<std::string>> buckets(256);

    for (int pos=stringLength-1; pos>=0; --pos) {
        for (std::string &s: a)
            buckets[s[pos]].push_back(std::move(s));

        int index = 0;
        for (auto& bucket: buckets) {
            for (std::string& s: bucket)
                a[index++] = std::move(s);
            bucket.clear();
        }
    }
}


/**
  СОРТИРОВКИ ДРУГИХ ТИПОВ
  */

//Пусть нам даны два вектора длиной n и m. Требуется отсортировать вектор, состоящий из всех попарных
//произведений элементов этих векторов.
//Самый простой способ решить задачу - сначала составить вектор попарных произведений,
//а затем отсортировать его. Составление вектора имеет сложность O(nm), то есть квадратичную,
//сортировка вектора - не менее чем O(nm*log(nm)), то есть общая сложность квадратичная.

//Один из вариантов уменьшить сложность - отсортировать первый вектор. Затем взять
//первые два элемента из второго вектора и получить два вектора попарных произведений.
//Слить их алгоритмом merge (эти векторы будут отсортированы, поэтому merge здесь допустим).
//Рассчитаь третий вектор попарных произведений первого вектора на третий элемент второго,
//слить результат с предыдущим результатом слияния, и т.д. Такой алгоритм потребует уже
//O(nmlog(max(n,m))) операций.

//O(nm) + O(nm*log(nm))

std::vector<int> sortCartesianProductsWithMerge(std::vector<int> a, std::vector<int> b)
{
    const int n = a.size();
    const int m = b.size();

    //0. Простейшие проверки
    if (n==0 || m==0) return std::vector<int>();

    if (n==1) {
        std::sort(b.begin(), b.end());
        return b;
    }
    if (m==1) {
        std::sort(a.begin(), a.end());
        return a;
    }

    //сюда будем складывать результат
    std::vector<int> res(n*m);
    //временный вектор
    std::vector<int> temp(n*m);


    //1. сортируем больший вектор, так как тогда понадобится меньше последовательных слияний
    auto & firstVec = (n>m?a:b);
    auto & secondVec = (n>m?b:a);
    std::sort(firstVec.begin(), firstVec.end());
    auto &firstVecSize = (n>m?n:m);
    auto &secondVecSize = (n>m?m:n);

    //Начальное смещение в векторе res равно 0. Оно будет увеличиваться с шагом firstVecSize
    int offset = 0;

    //2. Инициализируем вектор res попарными произведениями первого вектора на первый элемент второго
    for (int i=0; i<firstVecSize; ++i)
        res[i+offset] = firstVec[i]*secondVec[0];

    offset += firstVecSize;

    //3. в цикле добавляем в res вектор попарных произведений
    for (int j = 1; j < secondVecSize; ++j) {

        for (int i=0; i<firstVecSize; ++i)
            res[i+offset] = firstVec[i]*secondVec[j];
        //и сливаем два вектора
        merge(res, temp, 0, j*firstVecSize, (j+1)*firstVecSize-1);
        offset += firstVecSize;
    }

    return res;
}

//2 7 8 11
//7 1 4 9
//14 49 56 77 0 0 ...
//14 49 56 77 2 7 8 11...
//2 7 8 11 14 49 56 77 8 28 32 44
//2 7 8 8 11 14 28 32 44 49 56 77 18

//Еще один подход - отсортировать второй вектор. Далее если представить попарные произведения
//в виде таблицы (то есть декартового произведения двух векторов), то можно заметить,
//что любой элемент в таблице не меньше своего нижнего соседа, если второй вектор
//соответствует строкам. То есть если мы в произвольной строке найдем минимальный элемент,
//то ниже его определенно будет больший. Алгоритм следующий:
//1. Посчитаем произведения первого вектора на первый элемент второго вектора.
//2. Найдем в получившемся векторе минимальный элемент. Выведем его.
//3. На место выведенного поместим элемент, равный произведению того же элемента первого вектора
//   на следующий элемент второго вектора.
//4. Если следущий элемент второго вектора отсутствует, то вставим максимально возможное число.
//5. Повторяем 2-3, пока все элементы во вспомогательном векторе не станут равны int_max.


int getMinIndex(const std::vector<int> &a)
{
    return std::distance(a.begin(), std::min_element(a.begin(), a.end()));
}

std::vector<int> sortCartesianProducts(std::vector<int> a, std::vector<int> b)
{
    const int n = a.size();
    const int m = b.size();

    //0. Простейшие проверки
    if (n==0 || m==0) return std::vector<int>();

    if (n==1) {
        std::sort(b.begin(), b.end());
        return b;
    }
    if (m==1) {
        std::sort(a.begin(), a.end());
        return a;
    }

    //1. Сортируем второй вектор
    std::sort(b.begin(), b.end()); //стандартный алгоритм имеет сложность не хуже O(n*logn)

    //2. Сюда будем складывать результат
    std::vector<int> cartesianProduct(n*m);

    //это индекс в векторе результата
    int index = 0;

    //Это вспомогательный вектор, хранящий попарные произведения для вектора a
    std::vector<int> temp(n);

    //4. Получаем попарные произведения
    for (int i=0; i<n; ++i) temp[i] = b[0]*a[i];

    //это вспомогательный вектор, хранящий индексы элементов из вектора b, которые были
    //использованы в векторе temp

    std::vector<int> indexes(n);

    //5. Общий цикл
    while (true) {
        //получаем индекс минимального элемента
        int minIndex = getMinIndex(temp);
        //условие выхода из цикла - если минимальный элемент равен INT_MAX
        if (temp[minIndex]==INT_MAX) break;
        //добавляем найденный элемент в результирующий вектор
        cartesianProduct[index++]=temp[minIndex];
        //заменяем извлеченный элемент нижним
        indexes[minIndex]++; //смещаем индекс в векторе b
        if (indexes[minIndex]>=m) temp[minIndex]=INT_MAX; //проверяем, не достигли ли конца вектора b
        else temp[minIndex] = b[indexes[minIndex]]*a[minIndex];

//        std::cout << "temp ";
//        printVec(temp);
//        std::cout << std::endl;

//        std::cout << "indexes ";
//        printVec(indexes);
//        std::cout << std::endl;
    }

    return cartesianProduct;
}

#endif // SORTING_H
